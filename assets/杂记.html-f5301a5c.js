import{_ as s,$ as d,a0 as m,a1 as a,a2 as e,a3 as i,a4 as n,a5 as l,w as o}from"./framework-b3a0f150.js";const p={},c=l(`<h2 id="top、htop命令显示的res列" tabindex="-1"><a class="header-anchor" href="#top、htop命令显示的res列" aria-hidden="true">#</a> top、htop命令显示的res列，</h2><p>这个res展示的是操作系统看到的进程使用内存，至于进程到底有没有吧这些res内存使用完，只有进程自己知道。（甚至于res的值可以大于物理内存总量） 这也就解释了，为什么某个java进程dump出来的堆文件比如只有1G，但是res显示却大于1G，比如显示2G,3G甚至更高 <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-25/276298691412800.png" alt="" loading="lazy"> 如上图，htop命令显示进程4529使用了3.6G内存，但通过dump文件只有100m样子，也就是上图显示的used的大小， 而res显示的内存和上图中的total显示的内存基本一直。</p><h2 id="dump文件会包含直接内存的信息吗" tabindex="-1"><a class="header-anchor" href="#dump文件会包含直接内存的信息吗" aria-hidden="true">#</a> dump文件会包含直接内存的信息吗？</h2><p>不会 我们分配了100m的directBytebuffer，然后执行dump操作，dump文件的大小基本和used显示的大小一直，明细没有包含直接内存的信息 同理，mappedbytebuffer的内存也不会显示在dump文件中</p><h2 id="dump文件包含了哪些内存信息" tabindex="-1"><a class="header-anchor" href="#dump文件包含了哪些内存信息" aria-hidden="true">#</a> dump文件包含了哪些内存信息？</h2><p><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-25/278563693671900.png" alt="" loading="lazy"> 包含的是上图中的第一个框里面的信息，可以通过mat分析dump文件后得到的size数据看，这个size的数据和第一个框的数据是吻合的</p><h2 id="proc-meminfo" tabindex="-1"><a class="header-anchor" href="#proc-meminfo" aria-hidden="true">#</a> /proc/meminfo</h2><p>服务器内存相关的信息</p><h2 id="proc-pid-maps和-proc-pid-smaps" tabindex="-1"><a class="header-anchor" href="#proc-pid-maps和-proc-pid-smaps" aria-hidden="true">#</a> /proc/pid/maps和/proc/pid/smaps</h2><p>两个大同小异，smaps 可以展示更详细的信息 这个两个文件展示的信息基本可以替代pmap命令的输出</p><h2 id="proc-pid-status" tabindex="-1"><a class="header-anchor" href="#proc-pid-status" aria-hidden="true">#</a> /proc/pid/status</h2><p>可以查看进程的一些统计数据，包含使用的内存等 使用的内存：VmRSS 指标 所以查看某个进行使用的内存时候，可以通过这个指标获取，而不用通过top去观察获得</p><h2 id="gdb-attach-pid" tabindex="-1"><a class="header-anchor" href="#gdb-attach-pid" aria-hidden="true">#</a> gdb attach pid</h2><p>注意：这个命令会阻塞整个进程，慎用 然后执行命令： dump memory dumpfilename startAddr endAddr 这个上面的dump命令，可以把进程中指定地址的内存给dump下来 这里的startAddr和endAddr可以通过上面的maps和smaps获得（前面记得加0x）</p><p>然后可以通过strings dumpfilename查看大概内容 如果指定地址空间里没有存放任何东西，那么上面的strings命令没有任何输出</p><p>strings -10 sshd.dump 查看文件中大于10个字符的信息</p><h2 id="青年代和老年的的占比" tabindex="-1"><a class="header-anchor" href="#青年代和老年的的占比" aria-hidden="true">#</a> 青年代和老年的的占比</h2><p>默认是1:2，也就是默认-XX:NewRatio 的值是2 如果设置 XX:NewRatio 为4 表示 青年代和老年的的占比是1:4</p><h2 id="青年代中survivor和eden区的占比" tabindex="-1"><a class="header-anchor" href="#青年代中survivor和eden区的占比" aria-hidden="true">#</a> 青年代中survivor和eden区的占比</h2><p>默认是1:8，也就是 -XX:SurvivorRatio的默认值是8 -XX:SurvivorRatio: 8Eden区与survivor大小比值</p><h2 id="linux系统调用mmap与munmap" tabindex="-1"><a class="header-anchor" href="#linux系统调用mmap与munmap" aria-hidden="true">#</a> Linux系统调用mmap与munmap</h2><p>mmap函数用于申请一段内存空间，我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中 munmap函数则用于释放有mmap创建的这段内存空间。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#inlcude&lt;sys/mann.h&gt;
void mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *start, size_t length);
/*
void *start 允许用户使用某一个人特定的地址为有这段内存的起始位置。如果他被设置为NULL，则系统自动分配一个地址。
size_t length 此参数制定了内存段的长度
int prot 此参数设置内存段访问权限：
		PROT_READ:可读
		PROT_WRITE:可写
		PROT_EXEC:可执行
		PROT_NONE:内存段不能被访问
int flags 此参数控制内存段内容被修改后程序的行为。它可以被设置为以下值的按位或（MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）
		MAP_SHARED:在进程间共享这段内存。对该内存段的修改将反应到被映射的文件中。它提供了进程间共享内存的POSIX方法
		MAP_PRIVATE:内存段调用为进程私有，对该内存段的修改不会反应到被映射的文件中
		MAP_ANONYMOUS:这段内存不是从文件映射而来的，其内容被初始化为全0，这种情况下，mmap函数的最后两个参数将被忽略
		MAP_FIXED:内存段必须位于start参数指定的地址处。start必须是内存页面大小（4096）的整数倍
		MAP_HUGETLB:按照大内存页面来分配内存空间。大内存页面的大小可以通过/pro/meminfo文件来查看
int fd 此参数是被映射文件对应的文件描述符。他一般通过open系统调用获得。
off_t offset此参数设置从文件的何处开始映射（对于不需要读入整个文件的情况）

mmap函数成功时返回指向目标内存区域的指针，失败则返回MAO_FAILED((void*)-1)并设置errno

munmap函数成功返回0.失败返回-1并设置errno
*/

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="java-nmt-native-memory-tracking" tabindex="-1"><a class="header-anchor" href="#java-nmt-native-memory-tracking" aria-hidden="true">#</a> Java NMT (Native Memory Tracking)</h2><ol><li><p>重启java进程，添加-XX:NativeMemoryTracking=detail虚拟机参数</p></li><li><p>执行jcmd 31780 VM.native_memory detail | less 查看，如下图（下图是jdk1.8的输出，jdk11的输出有些不一样，所以下面的结论要辩证看待） <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-26/341524306429700.png" alt="" loading="lazy"></p></li><li><p>通过unsafe.allocateMemory方法分配的内存会在 Internal 中体现出来，具体是 malloc 这块，System.gc()后，数据会缩小</p></li><li><p>常用的new这些方法分配的内存会在 Java Heap中提醒，具体是mmap这块，System.gc()后，数据不会缩小</p></li></ol><h2 id="mmap-malloc" tabindex="-1"><a class="header-anchor" href="#mmap-malloc" aria-hidden="true">#</a> mmap/malloc</h2><p>操作系统针对内存分配提供了两种方式：brk和mmap</p><ol><li>brk: brk的实现是在data segment段的最高地址指针(_edata)往高位地址移动（分配的内存小于128k）</li><li>mmap: mmap的实现是在memory mapping segment段找一块空闲的虚拟内存（分配的内存大于128k） <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-26/2630224691000.png" alt="" loading="lazy"></li></ol><p>上面提到的128k，通过gperftools工具或strace命令监控发现上面128k的分界线貌似不是那么回事，目前可不用纠结，只需记得1 2的前半部分和上面的图即可</p><p>mmap除了能分配内存外，还能建立磁盘文件到虚拟内存直接的映射关系 <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-26/3322442824900.png" alt="" loading="lazy"></p><p><strong>注意</strong> ：brk和mmap分配的都是虚拟内存，并没有分配物理内存。当第一次访问分配的虚拟内存的是，发生缺页中断，这个时候操作系统才会分配物理内存，然后在页表中建立虚拟内存与物理内存直接的映射关系</p>`,31),h={start:"3"},u=a("li",null,[a("p",null,"malloc: malloc函数封装了brk和mmap，当分配的内存小于128k的时候使用brk，反之使用mmap（这个结论辩证看待，貌似和实际不一致，可以认为没有这条）")],-1),g={href:"https://www.cnblogs.com/dream397/p/14629276.html",target:"_blank",rel:"noopener noreferrer"},E=l('<h2 id="为什么mmap能减少内存拷贝" tabindex="-1"><a class="header-anchor" href="#为什么mmap能减少内存拷贝" aria-hidden="true">#</a> 为什么mmap能减少内存拷贝？</h2><ol><li>当我们使用mmap分配内存（从上面可知，这是虚拟内存），并传递相关的磁盘文件相关参数试，操作系统就会在虚拟内存中分配一块内存，并把这块内存和磁盘文件关联</li><li>当我们第一次读取这块内存的时候，发生缺页中断，操作系统会把读取磁盘文件并拷贝到物理内存（内核空间），同时也会在页表中建立虚拟内存与物理内存的映射关系。</li><li>不使用mmap的情况下，操作系统会先把磁盘文件拷贝到物理内存（内核空间），然后再把数据从物理内存（内核空间）拷贝一份到物理内存（用户空间） <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-26/3278725046900.png" alt="" loading="lazy"></li></ol><h2 id="看个好玩的" tabindex="-1"><a class="header-anchor" href="#看个好玩的" aria-hidden="true">#</a> 看个好玩的</h2><figure><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-31/432844177248000.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图中物理内存只有15.5G，但top命令显示这个java进程的res有25.1G.</p><p>目前不知道缘由，可通过如下步骤重现 <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-08-31/432995701015200.png" alt="" loading="lazy"> 多次执行上诉代码即可，上面代码中的fileName的磁盘文件大小是478m样子，没执行一次，res基本就会增加近1000m样子，(mmap500m,java程序分配byte数组500m) 再执行gc后，res会减少大概500m,减少的是java程序中byte数组的那500m,mmap的500m不会减少。 所以规律应该是： 执行n次上面代码后再执行一次gc,res会增加大概n*500m的大小（对应的就是mmap产生的内存），java程序堆的内存基本不变</p><figure><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-01/515656624116800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="cookie的domain属性" tabindex="-1"><a class="header-anchor" href="#cookie的domain属性" aria-hidden="true">#</a> cookie的domain属性</h2><figure><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-19/1039656530582500.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>设置domain的值，前面带点和不带点的区别：</p><ol><li>带点：任何subdomain都可以访问，包括父domain</li><li>不带点：只有完全一样的域名才能访问，subdomain不能访问(但在IE下比较特殊，它支持subdomain访问)</li></ol><h2 id="localstorage" tabindex="-1"><a class="header-anchor" href="#localstorage" aria-hidden="true">#</a> localStorage</h2><ol><li>localStorage是无法跨域的，也无法让子域名继承父域名的localStorage数据</li><li>LocalStorage是不能跨域的，但是，可以借助postMessage和iframe来实现跨域的数据读取</li></ol><h2 id="sso-single-sign-on-单点登陆" tabindex="-1"><a class="header-anchor" href="#sso-single-sign-on-单点登陆" aria-hidden="true">#</a> SSO( Single Sign On ) 单点登陆</h2><p>sso的实现需要依赖cookie，虽然通过localstorage也能辗转实现，但比较麻烦，所以一般sso的实现都利用了cookie 但cookie可能遇到的问题就是：</p><ol><li>用户禁用了cookie</li><li>csrf攻击 <blockquote><p>解决办法就是：cookie双重验证，比如后端往cookie写一个kv,uuid=xxxxx,xxxxx是一个随机值。 要求前端访问的时候需要读取cookie的中的这个uuid，并吧值放到url上或者header里，这样后端如果判断到两者数据一致，则认为请求合法 主要原理就是csrf的请求无法读取到cookie的值，只能是浏览器自动带上</p></blockquote></li></ol><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>',18),v=a("p",null,[a("br"),a("br"),a("br"),a("br"),a("br"),a("br")],-1),f=a("hr",null,null,-1),b=a("hr",null,null,-1),_=a("ul",null,[a("li",null,[a("strong",null,"随机毒鸡汤"),e("：我觉得，我是小时候兴趣班上多了，长大才没兴趣上班。 "),a("br"),a("br"),a("img",{src:"https://images.pexels.com/photos/8969189/pexels-photo-8969189.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"Monochrome portrait of a smiling man indoors in Kazakhstan.",loading:"lazy"})])],-1);function A(B,k){const r=o("ExternalLinkIcon"),t=o("RouterLink");return d(),m("div",null,[c,a("ol",h,[u,a("li",null,[a("p",null,[e("扩展阅读： "),a("a",g,[e("https://www.cnblogs.com/dream397/p/14629276.html"),i(r)])])])]),E,a("ul",null,[a("li",null,[i(t,{to:"/other/getPath%20vs%20getAbsolutePath%20vs%20getCanonicalPath.html"},{default:n(()=>[e("getPath vs getAbsolutePath vs getCanonicalPath")]),_:1})]),a("li",null,[i(t,{to:"/other/JetBrains%20IDE%20%E5%85%A8%E7%A0%B4%E8%A7%A3.html"},{default:n(()=>[e("JetBrains IDE 全破解")]),_:1})]),a("li",null,[i(t,{to:"/other/Nacos-Spring%20Gateway-Spring%20boot%E6%97%A0%E6%84%9F%E5%8F%91%E5%B8%83.html"},{default:n(()=>[e("Nacos-Spring Gateway-Spring boot无感发布")]),_:1})]),a("li",null,[i(t,{to:"/software/jvm/JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.html"},{default:n(()=>[e("JVM参数设置")]),_:1})]),a("li",null,[i(t,{to:"/software/unclassified/%E6%B5%8B%E8%AF%95%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E7%9A%84%E7%BD%91%E9%80%9F.html"},{default:n(()=>[e("测试两台服务器间的网速")]),_:1})]),a("li",null,[i(t,{to:"/other/MongoDB%E9%AB%98%E5%8F%AF%E7%94%A8.html"},{default:n(()=>[e("MongoDB高可用")]),_:1})]),a("li",null,[i(t,{to:"/other/istio%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"},{default:n(()=>[e("istio基础知识")]),_:1})]),a("li",null,[i(t,{to:"/software/unclassified/linux_no_space_left_on_device.html"},{default:n(()=>[e("linux_no_space_left_on_device")]),_:1})]),a("li",null,[i(t,{to:"/software/middleware/es/ES%E6%9D%82%E9%A1%B9.html"},{default:n(()=>[e("ES杂项")]),_:1})]),a("li",null,[i(t,{to:"/other/%E5%85%8D%E8%B4%B9%20API%20%E6%AF%8F%E6%97%A5%E6%8F%90%E4%BE%9B%E6%91%B8%E9%B1%BC%E6%97%A5%E6%8A%A5%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%97%A0%E6%B0%B4%E5%8D%B0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"},{default:n(()=>[e("免费 API 每日提供摸鱼日报，自动返回无水印图片，适用于公众号和小程序")]),_:1})]),a("li",null,[i(t,{to:"/software/spring/SpringCloud%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86.html"},{default:n(()=>[e("SpringCloud总体认识")]),_:1})]),a("li",null,[i(t,{to:"/other/CentOS7%E4%B8%8BDocker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%90%8E%E9%98%B2%E7%81%AB%E5%A2%99%E5%A4%B1%E6%95%88.html"},{default:n(()=>[e("CentOS7下Docker端口映射后防火墙失效")]),_:1})])]),v,f,b,_])}const y=s(p,[["render",A],["__file","杂记.html.vue"]]);export{y as default};
