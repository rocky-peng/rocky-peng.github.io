import{_ as i,$ as l,a0 as r,a1 as a,a3 as s,a4 as t,a5 as o,a2 as e,w as d}from"./framework-8c4427da.js";const c={},p=o(`<p>sync是jvm的内置锁，底层是通过对象监视器(ObjectMonitor)来实现。而对象监视器的底层实现是通过<strong>cas+自旋</strong>或者<strong>操作系统的互斥量</strong>来实现的。通过javap -c 命令可以查看到sync方法前后有成对的monitorenter/monitorexit指令。</p><p>ObjectMonitor的结构 <img src="https://cdn.justdopay.top/xiaoshujiang/1629079090127.png" alt="" loading="lazy"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>cas<span class="token operator">:</span> compare and swap ，比对并交换。
这个操作是cpu指令级的功能，可以保证原子性。
这个操作需要三个参数：<span class="token number">1.</span>数据存放的地址<span class="token class-name">Addr</span>  <span class="token number">2.</span>原来的值<span class="token class-name">A</span>  <span class="token number">3.</span>期望改变后的值<span class="token class-name">B</span>。
只有当<span class="token class-name">Addr</span>数据为<span class="token class-name">A</span>的时候才会成功把值更改为<span class="token class-name">B</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cas的三大问题" tabindex="-1"><a class="header-anchor" href="#cas的三大问题" aria-hidden="true">#</a> CAS的三大问题</h2><ul><li><p>ABA问题</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cas的ABA问题: 描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。
这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，
最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，
所以 compareAndSet 操作是成功。 这在某些场景是不允许的

一个不恰当的例子：公司有一笔专款专用的钱100万，在公司真正支出这笔钱之前，公司财务挪用这笔钱借给了自己的某个朋友，
然后这个朋友归还了回来。归还之后公司正常使用了这笔钱，表面上对公司没有任何影响，但挪用公款这个行为是违法不允许的。

如何解决这个问题：增加一个版本号。 Java中的AtomicStampedReference通过版本号解决了这个问题。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>循环时间长开销大</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>一般cas都会配合一个循环来使用，所以如果cas长时间不成功，是很消耗cpu的。所以一般还要配合LockSurport.park使用
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>只能保证一个变量的原子操作</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>可以把多个变量封装在一个对象里，然后通过AtomicReference来进行操作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><p>在jvm早期中，sync是通过操作系统的互斥量来实现的，这就会涉及到操作系统的用户态和内核态的切换，这是非常消耗系统资源的操作。所以后来引入了轻量级锁，即通过cas+自旋的方式来实现。</p><p>那么执行同步代码块的线程是如何进行同步的呢？它们总有一个共同的存储锁信息的地方吧？ 是的，那就是对象的<strong>mark word</strong>（上图ObjectMonitor中的_header字段）。</p><p>对象的mark word在什么地方呢？ 在对象的对象头里。这里扩展下对象在jvm中的内存结构：</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079098757.png" alt="对象结构" tabindex="0" loading="lazy"><figcaption>对象结构</figcaption></figure><p>我们重点关注下对象头中的mark word，那么mark word的结构又是怎样的呢？32位jvm中如下： <img src="https://cdn.justdopay.top/xiaoshujiang/1629079105518.png" alt="mark word结构" loading="lazy"></p><p>线程就是通过对象的mark word来进行同步的。</p><p>在上图可以看到mark word中记录了对象锁的状态，分为无锁、偏向锁、轻量级锁、重量级锁。这几种状态的转变规则为无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，这个规则称之为锁的升级。<strong>注意：锁只能升级不能降级。但偏向锁可以降级为无锁，其他的不行。</strong></p><h2 id="锁的升级过程" tabindex="-1"><a class="header-anchor" href="#锁的升级过程" aria-hidden="true">#</a> 锁的升级过程</h2><p>见图：</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079120186.png" alt="sync锁的升级过程" tabindex="0" loading="lazy"><figcaption>sync锁的升级过程</figcaption></figure><p>这张图用文字描述清楚感觉太费劲，文字还多，说不定吃力不讨好，所以这个图要慢慢品，细细品，多次品。品的时候建议假设有多个线程在竞争锁。</p><p>品的时候有个难点可能是偏向锁的撤销那，<strong>偏向锁的撤销是在有锁竞争的情况下才会撤销</strong>。为什么呢 ？我们优先要明白偏向锁的设计目的是什么？ 因为可能存在这种情况：这个同步代码块只有一个线程在访问。如果没有偏向锁，那么根据上图这个线程会多次进行cas操作，这个显然是没有必要的，于是为了优化就设计了偏向锁。使得在只有一个线程访问同步代码块的时候，只需要比对之前偏向的线程是不是自己，如果是，则获得锁。</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h2><p>sync的对象不要使用String Integer Long等基础对象，因为这些对象存在缓存原因，可能锁到其他线程用的对象。</p><h2 id="sync和reentrantlock的区别" tabindex="-1"><a class="header-anchor" href="#sync和reentrantlock的区别" aria-hidden="true">#</a> sync和ReentrantLock的区别</h2><ol><li>两者都是可重入的（sync的重入次数保存在哪里的呢？）</li><li>sync是基于jvm实现的，是隐式锁，而ReentrantLock是基于java api实现的，是显式锁。</li><li>ReentrantLock 比 synchronized 更加灵活 <ol><li>可以试探性获得锁（tryLock）</li><li>等待可中断；(acquireInterruptibly)</li><li>可实现公平锁，sync是非公平的</li><li>可实现选择性通知，也就是可以创建多个条件队列</li><li>性能上已经不是一个选择因素了。sync做了各种优化（偏向锁、自旋锁、锁粗化、锁消除等等）</li></ol></li></ol><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><h3 id="矛盾1" tabindex="-1"><a class="header-anchor" href="#矛盾1" aria-hidden="true">#</a> 矛盾1</h3><p>A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p><p>B: 锁大多数情况都是在很短的时间执行完成。</p><p>解决方案: 引入轻量锁(通过自旋来完成锁竞争)。</p><h3 id="矛盾2" tabindex="-1"><a class="header-anchor" href="#矛盾2" aria-hidden="true">#</a> 矛盾2</h3><p>A: 轻量级锁中的自旋: 占用CPU时间，增加CPU的消耗(因此在多核处理器上优势更明显)。</p><p>B: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源。</p><p>解决方案: JDK5中引入默认自旋次数为10(用户可以通过-XX:PreBlockSpin进行修改)， JDK6中更是引入了自适应自旋（简单来说如果自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁，实际场景中，HotSpot认为最佳时间应该是一个线程上下文切换的时间，而是否自旋以及自旋次数更是与对CPUs的负载、CPUs是否处于节电模式等息息相关的)。</p><h3 id="矛盾3" tabindex="-1"><a class="header-anchor" href="#矛盾3" aria-hidden="true">#</a> 矛盾3</h3><p>A: 项目中代码块中可能绝大情况下都是多线程访问。</p><p>B: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少。</p><p>解决方案: 可以使用-XX:-UseBiasedLocking=false禁用偏向锁。</p><h3 id="矛盾4" tabindex="-1"><a class="header-anchor" href="#矛盾4" aria-hidden="true">#</a> 矛盾4</h3><p>A: 代码中JDK原生或其他的工具方法中带有大量的加锁。</p><p>B: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)。</p><p>解决方法: 引入<strong>锁削除</strong>(虚拟机即时编译器(JIT)运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)。</p><h3 id="矛盾5" tabindex="-1"><a class="header-anchor" href="#矛盾5" aria-hidden="true">#</a> 矛盾5</h3><p>A: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对同一对象加锁。</p><p>B: 由于在频繁的执行中，反复的加锁和解锁，这种频繁的锁竞争带来很大的性能损耗。</p><p>解决方法: 引入<strong>锁扩大/锁膨胀</strong>(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在它们外部)。</p><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,44),u=a("p",null,[a("br"),a("br"),a("br"),a("br"),a("br"),a("br")],-1),h=a("hr",null,null,-1),m=a("hr",null,null,-1),E=a("ul",null,[a("li",null,[a("strong",null,"随机毒鸡汤"),e("：我能对你最好的祝福，就是参加你的每一次婚礼。 "),a("br"),a("br"),a("img",{src:"https://images.pexels.com/photos/30865750/pexels-photo-30865750.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"Professional equestrian holding a horse with a rider atop, poised in modern riding gear outdoors.",loading:"lazy"})])],-1);function A(g,B){const n=d("RouterLink");return l(),r("div",null,[p,a("ul",null,[a("li",null,[s(n,{to:"/software/unclassified/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html"},{default:t(()=>[e("记一次内存泄漏")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/Btrace%E5%85%A5%E9%97%A8.html"},{default:t(()=>[e("Btrace入门")]),_:1})]),a("li",null,[s(n,{to:"/software/java-basic/%E5%BC%B1%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B.html"},{default:t(()=>[e("弱引用示例")]),_:1})]),a("li",null,[s(n,{to:"/other/JetBrains%20IDE%20%E5%85%A8%E7%A0%B4%E8%A7%A3.html"},{default:t(()=>[e("JetBrains IDE 全破解")]),_:1})]),a("li",null,[s(n,{to:"/other/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%97%EF%BC%9F.html"},{default:t(()=>[e("你真的会拼接字符串吗？")]),_:1})]),a("li",null,[s(n,{to:"/other/Spring%20RetryTemplate.html"},{default:t(()=>[e("Spring RetryTemplate")]),_:1})]),a("li",null,[s(n,{to:"/software/maccms/MAC%20CMS.html"},{default:t(()=>[e("MAC CMS")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/linux_no_space_left_on_device.html"},{default:t(()=>[e("linux_no_space_left_on_device")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/Flutter%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2.html"},{default:t(()=>[e("Flutter开发需要涉及的知识点大纲")]),_:1})]),a("li",null,[s(n,{to:"/software/java-basic/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html"},{default:t(()=>[e("AQS源码解读")]),_:1})]),a("li",null,[s(n,{to:"/other/%E5%85%8D%E8%B4%B9%20API%20%E6%AF%8F%E6%97%A5%E6%8F%90%E4%BE%9B%E6%91%B8%E9%B1%BC%E6%97%A5%E6%8A%A5%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%97%A0%E6%B0%B4%E5%8D%B0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"},{default:t(()=>[e("免费 API 每日提供摸鱼日报，自动返回无水印图片，适用于公众号和小程序")]),_:1})]),a("li",null,[s(n,{to:"/other/WebSocket%20SpringBoot%20Demo.html"},{default:t(()=>[e("WebSocket SpringBoot Demo")]),_:1})])]),u,h,m,E])}const b=i(c,[["render",A],["__file","synchronized原理深度剖析.html.vue"]]);export{b as default};
