import{y as m,E as D,L as P,j,t as A}from"./layout-61b0da4f-388282f4.js";import{r as U,S as _,e as $,a as H,l as M,i as B,h as Q,c as W,s as Z,n as q,I as O,_ as C}from"./edges-b7626ef5-fc63d43b.js";import{A as n,c as X,X as E,C as T}from"./mermaid.esm.min-3824ce45.js";import{U as z}from"./createText-8ec3b59b-df51d35a.js";var K=4;function V(r){return A(r,K)}function p(r){var e={options:{directed:r.isDirected(),multigraph:r.isMultigraph(),compound:r.isCompound()},nodes:Y(r),edges:ee(r)};return m(r.graph())||(e.value=V(r.graph())),e}function Y(r){return D(r.nodes(),function(e){var t=r.node(e),d=r.parent(e),i={v:e};return m(t)||(i.value=t),m(d)||(i.parent=d),i})}function ee(r){return D(r.edges(),function(e){var t=r.edge(e),d={v:e.v,w:e.w};return m(e.name)||(d.name=e.name),m(t)||(d.value=t),d})}let l={},w={},J={};const re=()=>{w={},J={},l={}},N=(r,e)=>(n.trace("In isDecendant",e," ",r," = ",w[e].includes(r)),!!w[e].includes(r)),te=(r,e)=>(n.info("Decendants of ",e," is ",w[e]),n.info("Edge is ",r),r.v===e||r.w===e?!1:w[e]?w[e].includes(r.v)||N(r.v,e)||N(r.w,e)||w[e].includes(r.w):(n.debug("Tilt, ",e,",not in decendants"),!1)),I=(r,e,t,d)=>{n.warn("Copying children of ",r,"root",d,"data",e.node(r),d);const i=e.children(r)||[];r!==d&&i.push(r),n.warn("Copying (nodes) clusterId",r,"nodes",i),i.forEach(o=>{if(e.children(o).length>0)I(o,e,t,d);else{const h=e.node(o);n.info("cp ",o," to ",d," with parent ",r),t.setNode(o,h),d!==e.parent(o)&&(n.warn("Setting parent",o,e.parent(o)),t.setParent(o,e.parent(o))),r!==d&&o!==r?(n.debug("Setting parent",o,r),t.setParent(o,r)):(n.info("In copy ",r,"root",d,"data",e.node(r),d),n.debug("Not Setting parent for node=",o,"cluster!==rootId",r!==d,"node!==clusterId",o!==r));const c=e.edges(o);n.debug("Copying Edges",c),c.forEach(g=>{n.info("Edge",g);const f=e.edge(g.v,g.w,g.name);n.info("Edge data",f,d);try{te(g,d)?(n.info("Copying as ",g.v,g.w,f,g.name),t.setEdge(g.v,g.w,f,g.name),n.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):n.info("Skipping copy of edge ",g.v,"-->",g.w," rootId: ",d," clusterId:",r)}catch(u){n.error(u)}})}n.debug("Removing node",o),e.removeNode(o)})},R=(r,e)=>{const t=e.children(r);let d=[...t];for(const i of t)J[i]=r,d=[...d,...R(i,e)];return d},x=(r,e)=>{n.trace("Searching",r);const t=e.children(r);if(n.trace("Searching children of id ",r,t),t.length<1)return n.trace("This is a valid node",r),r;for(const d of t){const i=x(d,e);if(i)return n.trace("Found replacement for",r," => ",i),i}},b=r=>!l[r]||!l[r].externalConnections?r:l[r]?l[r].id:r,ne=(r,e)=>{if(!r||e>10){n.debug("Opting out, no graph ");return}else n.debug("Opting in, graph ");r.nodes().forEach(function(t){r.children(t).length>0&&(n.warn("Cluster identified",t," Replacement id in edges: ",x(t,r)),w[t]=R(t,r),l[t]={id:x(t,r),clusterData:r.node(t)})}),r.nodes().forEach(function(t){const d=r.children(t),i=r.edges();d.length>0?(n.debug("Cluster identified",t,w),i.forEach(o=>{if(o.v!==t&&o.w!==t){const h=N(o.v,t),c=N(o.w,t);h^c&&(n.warn("Edge: ",o," leaves cluster ",t),n.warn("Decendants of XXX ",t,": ",w[t]),l[t].externalConnections=!0)}})):n.debug("Not a cluster ",t,w)}),r.edges().forEach(function(t){const d=r.edge(t);n.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),n.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(r.edge(t)));let i=t.v,o=t.w;if(n.warn("Fix XXX",l,"ids:",t.v,t.w,"Translating: ",l[t.v]," --- ",l[t.w]),l[t.v]&&l[t.w]&&l[t.v]===l[t.w]){n.warn("Fixing and trixing link to self - removing XXX",t.v,t.w,t.name),n.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),i=b(t.v),o=b(t.w),r.removeEdge(t.v,t.w,t.name);const h=t.w+"---"+t.v;r.setNode(h,{domId:h,id:h,labelStyle:"",labelText:d.label,padding:0,shape:"labelRect",style:""});const c=structuredClone(d),g=structuredClone(d);c.label="",c.arrowTypeEnd="none",g.label="",c.fromCluster=t.v,g.toCluster=t.v,r.setEdge(i,h,c,t.name+"-cyclic-special"),r.setEdge(h,o,g,t.name+"-cyclic-special")}else(l[t.v]||l[t.w])&&(n.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),i=b(t.v),o=b(t.w),r.removeEdge(t.v,t.w,t.name),i!==t.v&&(d.fromCluster=t.v),o!==t.w&&(d.toCluster=t.w),n.warn("Fix Replacing with XXX",i,o,t.name),r.setEdge(i,o,d,t.name))}),n.warn("Adjusted Graph",p(r)),L(r,0),n.trace(l)},L=(r,e)=>{if(n.warn("extractor - ",e,p(r),r.children("D")),e>10){n.error("Bailing out");return}let t=r.nodes(),d=!1;for(const i of t){const o=r.children(i);d=d||o.length>0}if(!d){n.debug("Done, no node has children",r.nodes());return}n.debug("Nodes = ",t,e);for(const i of t)if(n.debug("Extracting node",i,l,l[i]&&!l[i].externalConnections,!r.parent(i),r.node(i),r.children("D")," Depth ",e),!l[i])n.debug("Not a cluster",i,e);else if(!l[i].externalConnections&&r.children(i)&&r.children(i).length>0){n.warn("Cluster without external connections, without a parent and with children",i,e);let o=r.graph().rankdir==="TB"?"LR":"TB";l[i]&&l[i].clusterData&&l[i].clusterData.dir&&(o=l[i].clusterData.dir,n.warn("Fixing dir",l[i].clusterData.dir,o));const h=new P({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});n.warn("Old graph before copy",p(r)),I(i,r,h,i),r.setNode(i,{clusterNode:!0,id:i,clusterData:l[i].clusterData,labelText:l[i].labelText,graph:h}),n.warn("New graph after copy node: (",i,")",p(h)),n.debug("Old graph after copy",p(r))}else n.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l[i].externalConnections," no parent: ",!r.parent(i)," children ",r.children(i)&&r.children(i).length>0,r.children("D"),e),n.debug(l);t=r.nodes(),n.warn("New list of nodes",t);for(const i of t){const o=r.node(i);n.warn(" Now next level",i,o),o.clusterNode&&L(o.graph,e+1)}},k=(r,e)=>{if(e.length===0)return[];let t=Object.assign(e);return e.forEach(d=>{const i=r.children(d),o=k(r,i);t=[...t,...o]}),t},ie=r=>k(r,r.children()),de=(r,e)=>{n.info("Creating subgraph rect for ",e.id,e);const t=r.insert("g").attr("class","cluster"+(e.class?" "+e.class:"")).attr("id",e.id),d=t.insert("rect",":first-child"),i=X(E().flowchart.htmlLabels),o=t.insert("g").attr("class","cluster-label"),h=e.labelType==="markdown"?z(o,e.labelText,{style:e.labelStyle,useHtmlLabels:i}):o.node().appendChild(O(e.labelText,e.labelStyle,void 0,!0));let c=h.getBBox();if(X(E().flowchart.htmlLabels)){const a=h.children[0],s=T(h);c=a.getBoundingClientRect(),s.attr("width",c.width),s.attr("height",c.height)}const g=0*e.padding,f=g/2,u=e.width<=c.width+g?c.width+g:e.width;e.width<=c.width+g?e.diff=(c.width-e.width)/2-e.padding/2:e.diff=-e.padding/2,n.trace("Data ",e,JSON.stringify(e)),d.attr("style",e.style).attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-u/2).attr("y",e.y-e.height/2-f).attr("width",u).attr("height",e.height+g),i?o.attr("transform","translate("+(e.x-c.width/2)+", "+(e.y-e.height/2)+")"):o.attr("transform","translate("+e.x+", "+(e.y-e.height/2)+")");const y=d.node().getBBox();return e.width=y.width,e.height=y.height,e.intersect=function(a){return C(e,a)},t},oe=(r,e)=>{const t=r.insert("g").attr("class","note-cluster").attr("id",e.id),d=t.insert("rect",":first-child"),i=0*e.padding,o=i/2;d.attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-e.width/2-o).attr("y",e.y-e.height/2-o).attr("width",e.width+i).attr("height",e.height+i).attr("fill","none");const h=d.node().getBBox();return e.width=h.width,e.height=h.height,e.intersect=function(c){return C(e,c)},t},ae=(r,e)=>{const t=r.insert("g").attr("class",e.classes).attr("id",e.id),d=t.insert("rect",":first-child"),i=t.insert("g").attr("class","cluster-label"),o=t.append("rect"),h=i.node().appendChild(O(e.labelText,e.labelStyle,void 0,!0));let c=h.getBBox();if(X(E().flowchart.htmlLabels)){const a=h.children[0],s=T(h);c=a.getBoundingClientRect(),s.attr("width",c.width),s.attr("height",c.height)}c=h.getBBox();const g=0*e.padding,f=g/2,u=e.width<=c.width+e.padding?c.width+e.padding:e.width;e.width<=c.width+e.padding?e.diff=(c.width+e.padding*0-e.width)/2:e.diff=-e.padding/2,d.attr("class","outer").attr("x",e.x-u/2-f).attr("y",e.y-e.height/2-f).attr("width",u+g).attr("height",e.height+g),o.attr("class","inner").attr("x",e.x-u/2-f).attr("y",e.y-e.height/2-f+c.height-1).attr("width",u+g).attr("height",e.height+g-c.height-3),i.attr("transform","translate("+(e.x-c.width/2)+", "+(e.y-e.height/2-e.padding/3+(X(E().flowchart.htmlLabels)?5:3))+")");const y=d.node().getBBox();return e.height=y.height,e.intersect=function(a){return C(e,a)},t},se=(r,e)=>{const t=r.insert("g").attr("class",e.classes).attr("id",e.id),d=t.insert("rect",":first-child"),i=0*e.padding,o=i/2;d.attr("class","divider").attr("x",e.x-e.width/2-o).attr("y",e.y-e.height/2).attr("width",e.width+i).attr("height",e.height+i);const h=d.node().getBBox();return e.width=h.width,e.height=h.height,e.diff=-e.padding/2,e.intersect=function(c){return C(e,c)},t},le={rect:de,roundedWithTitle:ae,noteGroup:oe,divider:se};let F={};const ce=(r,e)=>{n.trace("Inserting cluster");const t=e.shape||"rect";F[e.id]=le[t](r,e)},he=()=>{F={}},G=async(r,e,t,d,i)=>{n.info("Graph in recursive render: XXX",p(e),i);const o=e.graph().rankdir;n.trace("Dir in recursive render - dir:",o);const h=r.insert("g").attr("class","root");e.nodes()?n.info("Recursive render XXX",e.nodes()):n.info("No nodes found for",e),e.edges().length>0&&n.trace("Recursive edges",e.edge(e.edges()[0]));const c=h.insert("g").attr("class","clusters"),g=h.insert("g").attr("class","edgePaths"),f=h.insert("g").attr("class","edgeLabels"),u=h.insert("g").attr("class","nodes");await Promise.all(e.nodes().map(async function(a){const s=e.node(a);if(i!==void 0){const v=JSON.parse(JSON.stringify(i.clusterData));n.info("Setting data for cluster XXX (",a,") ",v,i),e.setNode(i.id,v),e.parent(a)||(n.trace("Setting parent",a,i.id),e.setParent(a,i.id,v))}if(n.info("(Insert) Node XXX"+a+": "+JSON.stringify(e.node(a))),s&&s.clusterNode){n.info("Cluster identified",a,s.width,e.node(a));const v=await G(u,s.graph,t,d,e.node(a)),S=v.elem;_(s,S),s.diff=v.diff||0,n.info("Node bounds (abc123)",a,s,s.width,s.x,s.y),$(S,s),n.warn("Recursive render complete ",S,s)}else e.children(a).length>0?(n.info("Cluster - the non recursive path XXX",a,s.id,s,e),n.info(x(s.id,e)),l[s.id]={id:x(s.id,e),node:s}):(n.info("Node - the non recursive path",a,s.id,s),await H(u,e.node(a),o))})),e.edges().forEach(function(a){const s=e.edge(a.v,a.w,a.name);n.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),n.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(e.edge(a))),n.info("Fix",l,"ids:",a.v,a.w,"Translateing: ",l[a.v],l[a.w]),M(f,s)}),e.edges().forEach(function(a){n.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a))}),n.info("#############################################"),n.info("###                Layout                 ###"),n.info("#############################################"),n.info(e),j(e),n.info("Graph after layout:",p(e));let y=0;return ie(e).forEach(function(a){const s=e.node(a);n.info("Position "+a+": "+JSON.stringify(e.node(a))),n.info("Position "+a+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s&&s.clusterNode?B(s):e.children(a).length>0?(ce(c,s),l[s.id].node=s):B(s)}),e.edges().forEach(function(a){const s=e.edge(a);n.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(s),s);const v=Q(g,a,s,l,t,e,d);W(s,v)}),e.nodes().forEach(function(a){const s=e.node(a);n.info(a,s.type,s.diff),s.type==="group"&&(y=s.diff)}),{elem:h,diff:y}},pe=async(r,e,t,d,i)=>{U(r,t,d,i),Z(),q(),he(),re(),n.warn("Graph at first:",JSON.stringify(p(e))),ne(e),n.warn("Graph after:",JSON.stringify(p(e))),await G(r,e,d,i)};export{pe as x};
