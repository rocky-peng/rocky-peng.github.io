import{_ as o,$ as l,a0 as i,a1 as s,a3 as e,a4 as t,a5 as c,a2 as n,w as p}from"./framework-b3a0f150.js";const r={},d=c(`<p>大家好！今天我们要聊一个运维界的经典问题：<strong>如何判断某个端口是否通？</strong> 但这次的背景有点特殊——我们身处一个“荒凉”的环境：既没有 <code>telnet</code>，也没有 <code>nc</code>，甚至连安装它们的权限都没有。这就好比你被困在一座孤岛上，手里只有一把生锈的小刀，却要修好一艘破船。别慌！今天我来教你几招“土法炼钢”，用现有的工具玩出花样！</p><h2 id="背景-一场-残酷-的限制" tabindex="-1"><a class="header-anchor" href="#背景-一场-残酷-的限制" aria-hidden="true">#</a> <strong>背景：一场“残酷”的限制</strong></h2><p>想象一下，你正在排查一个网络问题，突然发现目标服务器的某个端口似乎挂了。于是，你满怀希望地输入：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>telnet <span class="token number">192.168</span>.1.100 <span class="token number">3306</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果系统无情地回怼你：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: telnet: <span class="token builtin class-name">command</span> not found
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你心想：“没事，还有 <code>nc</code>！” 结果又是一记暴击：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: nc: <span class="token builtin class-name">command</span> not found
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更惨的是，你尝试安装这些工具时，系统直接甩给你一句：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Permission denied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时，你可能会怀疑人生：难道我要靠意念测试端口吗？当然不用！以下方法绝对能让你笑对困境。</p><h2 id="方法一-用-dev-tcp-偷偷摸摸搞事情" tabindex="-1"><a class="header-anchor" href="#方法一-用-dev-tcp-偷偷摸摸搞事情" aria-hidden="true">#</a> <strong>方法一：用 <code>/dev/tcp</code> 偷偷摸摸搞事情</strong></h2><p>Bash 这个老朋友其实藏了一手绝活——<code>/dev/tcp</code>。它虽然看起来像个文件，但实际上可以用来测试 TCP 端口。就像你在电影里看到特工用牙签撬锁一样，这个方法低调又高效。</p><h3 id="操作步骤" tabindex="-1"><a class="header-anchor" href="#操作步骤" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>输入以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token operator">&gt;</span> /dev/tcp/<span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果端口通了，系统会默不作声（因为它害羞）。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: connect: Connection timed out
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果端口不通，系统会大声抗议：</li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token operator">&gt;</span> /dev/tcp/192.168.1.100/3306

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果返回 <code>Connection timed out</code>，说明端口要么太忙，要么根本不想理你。</p></li></ol><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li><code>/dev/tcp</code> 是 Bash 的隐藏技能，不是所有 Shell 都有。如果你用的是 <code>sh</code>，那不好意思，得先切换到 Bash（就像换上超级英雄的衣服）。</li><li>如果系统连 Bash 都没有，那你可能需要考虑跳槽到一个更有爱的环境。</li></ul><h2 id="方法二-用-curl-扮演-黑客" tabindex="-1"><a class="header-anchor" href="#方法二-用-curl-扮演-黑客" aria-hidden="true">#</a> <strong>方法二：用 <code>curl</code> 扮演“黑客”</strong></h2><p>如果系统中安装了 <code>curl</code>，你可以假装自己是个黑客，用它来测试端口。<code>curl</code> 虽然是 HTTP 工具，但它也支持其他协议，比如 <code>telnet</code>。这就像是用一把螺丝刀开红酒瓶塞——歪打正着，但效果杠杠的！</p><h3 id="操作步骤-1" tabindex="-1"><a class="header-anchor" href="#操作步骤-1" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>输入以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-v</span> telnet://<span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果端口通了，<code>curl</code> 会像导游一样带你参观连接详情。</p></li><li><p>如果端口不通，<code>curl</code> 会告诉你：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>curl: <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> Failed to connect to <span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span> port <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>: Connection timed out
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-v</span> telnet://192.168.1.100:3306
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-1" tabindex="-1"><a class="header-anchor" href="#注意-1" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 <code>curl</code>，别担心，你可以装个假发假装自己是 <code>curl</code>（开玩笑啦，请看方法三）。</li><li>这种方法适合那些喜欢“黑科技”的人，毕竟谁不想偶尔扮演一下黑客呢？</li></ul><h2 id="方法三-用-python-写个-侦探-脚本" tabindex="-1"><a class="header-anchor" href="#方法三-用-python-写个-侦探-脚本" aria-hidden="true">#</a> <strong>方法三：用 Python 写个“侦探”脚本</strong></h2><p>如果你的系统中有 Python，恭喜你！你可以写一个简单的脚本来当“侦探”，专门负责侦察端口的状态。Python 是个万能小助手，就像瑞士军刀一样，走到哪都能派上用场。</p><h3 id="脚本示例" tabindex="-1"><a class="header-anchor" href="#脚本示例" aria-hidden="true">#</a> <strong>脚本示例</strong></h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> socket

<span class="token keyword">def</span> <span class="token function">test_port</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 创建一个套接字对象</span>
        sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
        sock<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 设置超时时间为 5 秒</span>
        result <span class="token operator">=</span> sock<span class="token punctuation">.</span>connect_ex<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Port </span><span class="token interpolation"><span class="token punctuation">{</span>port<span class="token punctuation">}</span></span><span class="token string"> is open on </span><span class="token interpolation"><span class="token punctuation">{</span>host<span class="token punctuation">}</span></span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Port </span><span class="token interpolation"><span class="token punctuation">{</span>port<span class="token punctuation">}</span></span><span class="token string"> is closed or unreachable on </span><span class="token interpolation"><span class="token punctuation">{</span>host<span class="token punctuation">}</span></span><span class="token string">.&quot;</span></span><span class="token punctuation">)</span>
        sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Error: </span><span class="token interpolation"><span class="token punctuation">{</span>e<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token comment"># 测试目标地址和端口</span>
test_port<span class="token punctuation">(</span><span class="token string">&quot;&lt;目标地址&gt;&quot;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="操作步骤-2" tabindex="-1"><a class="header-anchor" href="#操作步骤-2" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>将 <code>&lt;目标地址&gt;</code> 和 <code>&lt;目标端口&gt;</code> 替换为实际值。</p></li><li><p>运行脚本：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>python3 detective.py
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-2" tabindex="-1"><a class="header-anchor" href="#注意-2" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 Python，那说明你的环境真的太“原始”了，建议给它升级一下（或者送它去博物馆参展）。</li><li>这个脚本就像一个私人侦探，专治各种“端口失踪案”。</li></ul><h2 id="方法四-用-ss-或-netstat-查-本地情报" tabindex="-1"><a class="header-anchor" href="#方法四-用-ss-或-netstat-查-本地情报" aria-hidden="true">#</a> <strong>方法四：用 <code>ss</code> 或 <code>netstat</code> 查“本地情报”</strong></h2><p>如果问题出在本地服务本身，可以检查服务器是否正在监听指定端口。这就像是在家里翻箱倒柜找钥匙，虽然笨，但有效。</p><h3 id="操作步骤-3" tabindex="-1"><a class="header-anchor" href="#操作步骤-3" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>使用 <code>ss</code> 或 <code>netstat</code> 查看监听的端口：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ss <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">netstat</span> <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果没看到目标端口，说明服务可能睡着了，或者干脆罢工了。</li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ss <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">3306</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-3" tabindex="-1"><a class="header-anchor" href="#注意-3" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 <code>ss</code> 或 <code>netstat</code>，那就只能靠耳朵听服务器有没有发出奇怪的声音了（开个玩笑，其实可以用方法五）。</li><li>这种方法适合那些喜欢“自检”的人，毕竟有时候问题就出在自己身上。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><p>在没有 <code>telnet</code> 和 <code>nc</code> 的世界里，我们依然可以用以下方法判断端口是否通：</p><ol><li>用 <code>/dev/tcp</code> 悄悄摸摸搞事情。</li><li>用 <code>curl</code> 扮演“黑客”。</li><li>用 Python 写个“侦探”脚本。</li><li>用 <code>ss</code> 或 <code>netstat</code> 查“本地情报”。</li></ol><p>每种方法都有它的乐趣和挑战，希望你能在这个受限环境中找到属于自己的快乐！<strong>记住，技术的世界没有绝境，只有创意不足的头脑！</strong> 😎</p><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,43),u=s("p",null,[s("br"),s("br"),s("br"),s("br"),s("br"),s("br")],-1),h=s("hr",null,null,-1),v=s("hr",null,null,-1),k=s("ul",null,[s("li",null,[s("strong",null,"随机毒鸡汤"),n("：冬天就是好，穷的时候，还有西北风喝。 "),s("br"),s("br"),s("img",{src:"https://images.pexels.com/photos/3178818/pexels-photo-3178818.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"A young woman works remotely at a café, using her laptop and external hard drive.",loading:"lazy"})])],-1);function m(b,g){const a=p("RouterLink");return l(),i("div",null,[d,s("ul",null,[s("li",null,[e(a,{to:"/software/unclassified/Git%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[n("Git笔记")]),_:1})]),s("li",null,[e(a,{to:"/software/unclassified/MAT%E5%B7%A5%E5%85%B7.html"},{default:t(()=>[n("MAT工具")]),_:1})]),s("li",null,[e(a,{to:"/software/middleware/redis/Redis%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[n("Redis笔记")]),_:1})]),s("li",null,[e(a,{to:"/software/unclassified/KVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85.html"},{default:t(()=>[n("KVM 虚拟机安装")]),_:1})]),s("li",null,[e(a,{to:"/other/JetBrains%20IDE%20%E5%85%A8%E7%A0%B4%E8%A7%A3.html"},{default:t(()=>[n("JetBrains IDE 全破解")]),_:1})]),s("li",null,[e(a,{to:"/software/unclassified/%E6%B5%8B%E8%AF%95%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E7%9A%84%E7%BD%91%E9%80%9F.html"},{default:t(()=>[n("测试两台服务器间的网速")]),_:1})]),s("li",null,[e(a,{to:"/software/unclassified/Markdown%20Mermaid%E7%94%BB%E5%9B%BE%E5%AE%9E%E4%BE%8B.html"},{default:t(()=>[n("Markdown Mermaid画图实例")]),_:1})]),s("li",null,[e(a,{to:"/other/PGSQL%20GIN%E7%B4%A2%E5%BC%95%E2%80%9C%E5%A4%B1%E6%95%88%E2%80%9D.html"},{default:t(()=>[n("PGSQL GIN索引“失效”")]),_:1})]),s("li",null,[e(a,{to:"/other/Spring%20RetryTemplate.html"},{default:t(()=>[n("Spring RetryTemplate")]),_:1})]),s("li",null,[e(a,{to:"/software/java-basic/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html"},{default:t(()=>[n("AQS源码解读")]),_:1})]),s("li",null,[e(a,{to:"/software/unclassified/Javassist%E6%95%B4%E7%90%86.html"},{default:t(()=>[n("Javassist整理")]),_:1})]),s("li",null,[e(a,{to:"/other/vuepress/vuepress-theme-hope%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97.html"},{default:t(()=>[n("vuepress-theme-hope使用心得")]),_:1})])]),u,h,v,k])}const f=o(r,[["render",m],["__file","在没有 telnet 和 nc 的世界里，如何优雅地判断端口是否通？.html.vue"]]);export{f as default};
