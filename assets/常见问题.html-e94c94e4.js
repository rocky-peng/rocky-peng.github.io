import{_ as o,$ as l,a0 as r,a1 as e,a3 as t,a4 as n,a5 as s,a2 as a,w as p}from"./framework-8c4427da.js";const d={},c=s(`<h2 id="如何解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#如何解决循环依赖的" aria-hidden="true">#</a> 如何解决循环依赖的</h2><p>先说网上流程很广的所谓的三级缓存吧 <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-16/758835364709600.png" alt="" loading="lazy"> 总之就是三个map。</p><p>假设A依赖B，B依赖A（非构造器互相依赖，构造器互相依赖无法解决） spring先创建a，然后把自己放到三级缓存中，然后进行依赖注入，发现依赖b,然后分别去一级、二级、三级缓存中找，都没找到 于是spring接着创建b，spring把b先new出来，然后把自己放入三级缓存中，然后进行依赖注入，发现依赖a，于是分别去一级、二级 三级缓存中找，结果在三级缓存中找到a，于是把a从三级缓存中移除并把a放到二级缓存中。然后b的依赖注入顺利完成，b创建成功，于是把自己从三级缓存中移除，放到一级缓存中。 然后回过了头接着对a进行依赖注入，然后再次从三个缓存中找，结果在一级缓存中找到了b，完成依赖注入，a创建完成，并把二级缓存中 移除，然后把自己放入一级缓存。</p><p>上面是网上广为流传的说法，这个说法我不是很赞同哈。</p><p>不赞同的点不是这个流程，这个流程应该和代码的相差不大，我不赞同的是我觉得这个说法夸大了所谓的缓存的作用，给人的感觉是因为三级缓存解决了循环依赖</p><p>实际不用三级，就用一个map也能搞定。因为只要能new出来，那么就能先能先让其他bean先引用</p><h2 id="beanfactory与factorybean的区别" tabindex="-1"><a class="header-anchor" href="#beanfactory与factorybean的区别" aria-hidden="true">#</a> BeanFactory与FactoryBean的区别</h2><p>看名字知道，BeanFactory是个bean工厂，也就是来生产bean的，由他生产的bean会经过spring的生命周期， 比如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>populateBean
initilaizeBean
    invokeAwareMethods
    applyBeanPostProcessorsBeforeInitialization
    invokeInitMethods
        InitializingBean#afterPropertiesSet
        自定义的init方法
    applyBeanPostProcessorsAfterInitialization
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后FactoryBean是一个bean， 他既是一个普通的bean,也不是一个普通的bean.</p><p>说他是普通bean，是因为他和我们平常写的controller，service等一样，创建factorybean的时候也会经过上面的生命周期。</p><p>说他不是普通的bean，是因为这个bean又可以通过调用getObject方法来创建bean并交给spring管理。但是通过这个方法创建的bean就不会经过上面的生命周期。 可以通过这种方式来创建第三方jar包里的实例对象。 <s>有点像我们平时用得@Bean注解一样</s>（@Bean注解创建的bean也会经过spring的生命周期）</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-16/758683689872700.png" alt="" loading="lazy"></h2><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-16/758694081149000.png" alt="" loading="lazy"></h2><figure><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-16/758714434336800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> spring事务</h2><p>按下面方式成对记忆</p><ol><li>REQUIRED， REQUIRED_NEW</li><li>SUPPORTS， NOT_SUPPORTED</li><li>MANDATORY， NEVER</li><li>NESTED</li></ol><h2 id="springbootapplication注解" tabindex="-1"><a class="header-anchor" href="#springbootapplication注解" aria-hidden="true">#</a> SpringBootApplication注解</h2><p>@SpringBootApplication可以看做下面三个注解的合集</p><ol><li><p>@Configuration</p><blockquote><p>允许在 Spring 上下文中注册额外的 bean 或导入其他配置类，用来标记当前类是一个配置类</p></blockquote></li><li><p>@ComponentScan</p><blockquote><p>扫描被@Component (@Repository,@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p></blockquote></li><li><p>@EnableAutoConfiguration</p><blockquote><p>启用 SpringBoot 的自动配置机制</p></blockquote></li></ol><p>重点说说 @EnableAutoConfiguration</p><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration</h3><figure><img src="https://cdn.justdopay.top/pasteimageintomarkdown/2022-09-16/771104096701700.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个注解上面有个import注解，import注解的使用看下文。 通过import注解导入了一个ImportSelector的实现类，类名想不起来了 我们知道如果导入的是一个ImportSelector的实现类，那么spring会执行里面的selectImports方法来得到需要创建 的bean的类全名。在这个实现类的这个方法里，会读取类路径下的spring.factories文件，这个文件就定义了各种普通类，配置类</p><p>总结：</p><ol><li><p>如果我们自己写了组件，想要给被人使用，就可以在jar包中添加spring.factories文件，并把相关的配置类写上去，这样其他人只需要吧 这个jar包放入类路径下即可</p></li><li><p>通过spring.factories文件的方式是不需要其他额外工作就可以激活相关功能的，我们还可以也写一个类似Enable的注解， 再这个注解上面加上Configuration注解，或者import注解，这样只要在启动类上加上这个注解就能激活相关功能</p></li></ol><h3 id="import注解" tabindex="-1"><a class="header-anchor" href="#import注解" aria-hidden="true">#</a> @Import注解</h3><p>可以导入几种类：</p><ol><li>普通类 <blockquote><p>这个情况会创建这个普通的实例</p></blockquote></li><li>ImportSelector实现类 <blockquote><p>如果导入的是这个类，就会执行这个类的importSelect方法，这个方法会返回需要创建的bean的类全名， 然后spring就会根据类全名创建bean</p></blockquote></li><li>ImportBeanDefinitionRegistrar实现类 <blockquote><p>导入这种类型的类，就会执行这个类的registerBeanDefinitions方法， 可以在这个方法里定义BeanDefinition并进行注册，这样spring就能根据 BeanDefinition来创建bean</p></blockquote></li></ol><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,32),u=e("p",null,[e("br"),e("br"),e("br"),e("br"),e("br"),e("br")],-1),h=e("hr",null,null,-1),E=e("hr",null,null,-1),b=e("ul",null,[e("li",null,[e("strong",null,"随机毒鸡汤"),a("：打败我的，不是天真，而是天真热。 "),e("br"),e("br"),e("img",{src:"https://images.pexels.com/photos/9212612/pexels-photo-9212612.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"Stunning aerial view of Harbin Ice and Snow Festival with intricate ice sculptures under a clear blue sky.",loading:"lazy"})])],-1);function g(B,m){const i=p("RouterLink");return l(),r("div",null,[c,e("ul",null,[e("li",null,[t(i,{to:"/software/unclassified/MAT%E5%B7%A5%E5%85%B7.html"},{default:n(()=>[a("MAT工具")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:n(()=>[a("批量修改git历史记录中的用户名和邮箱")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/index%E6%96%B9%E6%B3%95%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95.html"},{default:n(()=>[a("index方法压力测试记录")]),_:1})]),e("li",null,[t(i,{to:"/other/Paxos%E7%AE%97%E6%B3%95.html"},{default:n(()=>[a("Paxos算法")]),_:1})]),e("li",null,[t(i,{to:"/software/middleware/mysql/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB.html"},{default:n(()=>[a("异地多活")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/gperftools.html"},{default:n(()=>[a("gperftools")]),_:1})]),e("li",null,[t(i,{to:"/other/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E9%80%82%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7.html"},{default:n(()=>[a("推荐几个适用小工具")]),_:1})]),e("li",null,[t(i,{to:"/other/vuepress/vuepress-theme-hope%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97.html"},{default:n(()=>[a("vuepress-theme-hope使用心得")]),_:1})]),e("li",null,[t(i,{to:"/other/vuepress-theme-hope%20%E6%B7%BB%E5%8A%A0%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A.html"},{default:n(()=>[a("vuepress-theme-hope 添加谷歌广告")]),_:1})]),e("li",null,[t(i,{to:"/other/SpringBoot%E6%9C%8D%E5%8A%A1%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%AE%8C%E6%88%90%E5%89%8D%E8%A2%AB%E6%8F%90%E5%89%8D%E6%B3%A8%E5%86%8C%E5%88%B0nacos.html"},{default:n(()=>[a("SpringBoot服务在服务启动完成前被提前注册到nacos")]),_:1})]),e("li",null,[t(i,{to:"/other/Hbase%20%E6%80%BB%E8%A7%88.html"},{default:n(()=>[a("Hbase 总览")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/BBR%E5%8A%A0%E9%80%9F.html"},{default:n(()=>[a("BBR加速")]),_:1})])]),u,h,E,b])}const A=o(d,[["render",g],["__file","常见问题.html.vue"]]);export{A as default};
