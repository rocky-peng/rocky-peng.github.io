import{_ as r,$ as d,a0 as o,a1 as e,a3 as t,a4 as l,a5 as n,a2 as a,w as h}from"./framework-827a3556.js";const s={},c=n(`<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h1><h2 id="事务的一个实践问题" tabindex="-1"><a class="header-anchor" href="#事务的一个实践问题" aria-hidden="true">#</a> 事务的一个实践问题</h2><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629079599885.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>事务隔离级别：可重复读</p><p>存在上述情况的场景可能如下: 验证苹果的购买收据。</p><p>前端将购买的收据传递给server，server调用苹果接口执行校验操作，如果校验成功则更改订单状态</p><p>因为购买凭证不允许存在丢失，server端收到请求后应该立即执行保存，但并不能保证每个请求都保存成功，所以client端必须有重试机制，直到server端返回了指定的数据，</p><p>另外苹果的校验接口是第三方接口，所以系统必须假设调用第三方接口的时候出现各种问题，比如网络原因，第三方接口服务不可用或响应时间很慢的情况。因此server端的校也必须有重试机制，直到第三方接口返回了有效数据。</p><p>从上述校验过程可以知道server有可能不能及时响应给客户端，为了尽可能的将校验结果及时返回给前端，所以server接收到请求后采用 异步后再同步 的措施来处理（也可以采用 同步后再异步）。具体过程如下： 1.server接收到请求后，首先执行入库。如果入库失败，返回retry。入库成功后，执行下面的步骤 2.异步执行receipt的验证过程，校验成功或失败都要更新数据库，比如对校验执行的次数进行加1操作。 3.限时等待异步校验结果，如果指定时间内拿到结果，则直接返回给前端success或failure。如果指定时间内没有拿到结果，则返回proccessing。</p><p>上述过程如果实现不恰当会造成前端总是得到不success或failure的结果。比如这样实现：</p><p>threadA开启了事务tx1，执行了receipt的入库操作并获取了主键id。 然后将id传递给了threadB，让threadB异步执行校验过程，然后threadA限时等待threadB完成，比如30s。threadB拿到校验结果后开启tx2更新数据库。此时如果threadA的限时等待过程也在事务tx1内执行，那么就会出现前端总是拿不到suceess或failure的结果。因为threadA的实现要等待30s后才能提交事务tx1，而这个过程中threadB又要等待tx1的提交。所以造成了上诉结果。因此threadA的限时等待过程不能再tx1内执行，必须在tx1提交后再执行。</p><h2 id="一致性锁定读和一致性非锁定度的区别" tabindex="-1"><a class="header-anchor" href="#一致性锁定读和一致性非锁定度的区别" aria-hidden="true">#</a> 一致性锁定读和一致性非锁定度的区别</h2><p>就是加锁和不加锁的区别，一致性锁定读会对读取的数据加X锁或S锁，一致性非锁定读之所以可以不加锁，是因为它读取的是历史版本数据。 在read-committed下，读取的是最新版本的数据</p><p>在repeatable-read情况下读取的是事务开始时的版本数据。</p><h2 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> 索引类型</h2><ol><li>B+树索引 平衡N叉查找树</li><li>全文索引</li><li>哈希索引 innodb内部使用，不可人工干预</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>B+索引不能找到给定键值的具体行，只能找到数据行所在的页。然后数据库将该页数据读到数据库中，再在内存里进行查找。页中是按照主键顺序存放的，对于某条具体记录的查询是通过二分查找算法得到的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="相关数据结构和算法" tabindex="-1"><a class="header-anchor" href="#相关数据结构和算法" aria-hidden="true">#</a> 相关数据结构和算法</h2><ol><li><p>二分查找法 先将数据按照递增或递减的顺序进行排列，然后计算整个队列的中间位置，把中间位置的数据与目标数据进行查找，如果没有找到则在左半部分或右半部分继续采用这种方式进行查找。如果不考虑排序的时间复杂度，查找的时间复杂度为O(n);</p></li><li><p>二叉查找树 对于任何一个节点，左子树的键值总是小于节点自身的键值，右子树的键值总是大于节点自身的键值。</p></li><li><p>平衡二叉树 首先是一棵二叉查找树，另外需要满足任何节点的两个子树的高度差最大为1。 构造一棵平衡二叉树是通过左旋右旋来操作的，存在一定的维护成本，但多用在内存结构中，所以维护成本又相对小了很多。</p></li><li><p>B+树</p><ol><li>每个节点可以存放多个键值，按照顺序存放。</li><li>所有的记录都存在在叶子节点，同一层的叶子节点通过指针相连，组成类似一个双向循环链表的数据结构。</li><li>在数据库中，B+树的高度一般在2-4层，也就是执行一次查找最多需要2-4次IO</li></ol></li></ol><h2 id="b-索引" tabindex="-1"><a class="header-anchor" href="#b-索引" aria-hidden="true">#</a> B+索引</h2><ol><li><p>聚集索引</p></li><li><p>辅助索引</p></li><li><p>聚集索引和辅助索引的区别：</p><ol><li><p>无论是聚集索引还是辅助索引，都是B+树的结构。</p></li><li><p>两者区别主要是叶子节点存储的数据不一样。聚集索引的叶子节点存储的是整行的数据(确切的说是存储的是指向行数据的指针)，而辅助索引的叶子节点存储的是与之对应的主键值。因此通过辅助索引来查找数据需要两次查找索引。</p></li><li><p>个数不一样。一张innodb表最多只有一个主键，所以最多有一个聚集索引。而辅助所以可以有多个。</p></li></ol></li></ol><h2 id="聚集索引" tabindex="-1"><a class="header-anchor" href="#聚集索引" aria-hidden="true">#</a> 聚集索引</h2><p>就是按照每张表的主键构建一颗B+树，叶子节点存放的就是整行记录，成为<strong>数据页</strong>，数据页之间通过双向指针来进行连接。</p><p>因为每张表最多只有一个主键，所以每张表也最多拥有一个聚集索引。</p><p>聚集索引的结构只是逻辑结构，并不是物理结构。也就是说聚集在在物理存储上并不是连续的：</p><ol><li>页之间是通过指针来连接的：同层的数据页之间通过双向指针连接，数据页和索引页或者索引页之间通过单项指针连接。</li><li>索引页中存放的主键是顺序存放的。</li><li>数据页中的行记录之间是通过双向指针链接的，逻辑上是按照主键顺序存放的。</li></ol><p>也就是说物理存储上可以不按照主键顺序存储。</p><p>在表空间的物理存储文件中，即存放了索引页也存放了数据页。比如t.idb中即存放了表t的聚集索引的索引页也存放了数据页。也会存放辅助索引的索引页和数据页</p><p>从聚集索引的结构上可以知道：它对于主键的排序查找和范围查找是非常快的。因为在只要找到一个开始数据，就可以通过数据页之间的双向指针来快速定位下一条目标数据。</p><h2 id="fic-fast-index-creation" tabindex="-1"><a class="header-anchor" href="#fic-fast-index-creation" aria-hidden="true">#</a> FIC:fast index creation</h2><p>从MYSQL5.5开始或从InnoDB1.0.x开始支持FIC，会对表加上一个S锁，因此如果此时表上有有X或IX锁，那么fic操作会被阻塞。同事如果fic操作过程中有写操作或者dml，那么写也会被阻塞。</p><h2 id="oltp与olap的区别" tabindex="-1"><a class="header-anchor" href="#oltp与olap的区别" aria-hidden="true">#</a> OLTP与OLAP的区别</h2><p>oltp应用中，查询操作一般只充数据库中取出少量数据。而olap应用中，需要访问表中大量的数据，做一些统计操作，得出一些报表数据。</p><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h2><p>在辅助索引中就可以得到要查询的数据，而不需要再次查询聚集索引。如果explain结果集中的extra列显示有using index，则表示使用了覆盖索引。</p><h2 id="查询优化器什么时候会选择辅助索引来完成查询" tabindex="-1"><a class="header-anchor" href="#查询优化器什么时候会选择辅助索引来完成查询" aria-hidden="true">#</a> 查询优化器什么时候会选择辅助索引来完成查询？</h2><p>首先筛选的列存在相应的辅助索引。同时满足下面两个条件中一个 1. 可以使用覆盖索引 2. 如果不能使用覆盖索引，那么要查询的数据量要少于整张表数据的20%的样子。因为如果要查询大量的数据，那么还需要通过聚集索引来离散读，这个性能反而可能不好。</p><p>当然可以通过 use index 来强制使用指定的索引</p><h2 id="开启事务" tabindex="-1"><a class="header-anchor" href="#开启事务" aria-hidden="true">#</a> 开启事务</h2><p>mysql获取连接后，在执行begin（set autocommit =0）的时候，会检查当前连接中是否存在未提交的事务，如果存在会先提交之前的事务，然后再开启一个新的事务。也就是说如果在连续两次执行begin或set autocommit=0就会提交之前尚未提交的事务。</p><h2 id="commit-与-commit-work的区别" tabindex="-1"><a class="header-anchor" href="#commit-与-commit-work的区别" aria-hidden="true">#</a> commit 与 commit work的区别：</h2><p>当@@completion_type=0,两者等价 当@@completion_type=1,两者等价，意思是 commit and chain 当@@completion_type=2,两者等价，意思是 commit and release（执行这个后，会先commit，然后断开当前连接） 所以两者任何时刻都是等价的，只是跟随参数值的不同有不同含义。</p><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,44),p=e("p",null,[e("br"),e("br"),e("br"),e("br"),e("br"),e("br")],-1),E=e("hr",null,null,-1),u=e("hr",null,null,-1),B=e("ul",null,[e("li",null,[e("strong",null,"随机毒鸡汤"),a("：小时候我常想，长大了是上北大还是清华，现在想想原来是我想多了。 "),e("br"),e("br"),e("img",{src:"https://tuapi.eees.cc/api.php?category=fengjing&type=302&uuid=f7a7a6d8-13ca-4313-a4dc-1f42606d536e",alt:"",loading:"lazy"})])],-1);function m(f,A){const i=h("RouterLink");return d(),o("div",null,[c,e("ul",null,[e("li",null,[t(i,{to:"/software/unclassified/Btrace%E5%85%A5%E9%97%A8.html"},{default:l(()=>[a("Btrace入门")]),_:1})]),e("li",null,[t(i,{to:"/software/java-basic/%E5%BC%B1%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B.html"},{default:l(()=>[a("弱引用示例")]),_:1})]),e("li",null,[t(i,{to:"/software/spring/Spring%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%85%B3%E9%94%AE%E7%82%B9.html"},{default:l(()=>[a("Spring框架源码关键点")]),_:1})]),e("li",null,[t(i,{to:"/other/%E6%8F%90%E5%8F%96Docker%E9%95%9C%E5%83%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6.html"},{default:l(()=>[a("提取Docker镜像中的文件")]),_:1})]),e("li",null,[t(i,{to:"/other/Hadoop%20%E4%B8%80.html"},{default:l(()=>[a("Hadoop 一")]),_:1})]),e("li",null,[t(i,{to:"/other/PGSQL%20GIN%E7%B4%A2%E5%BC%95%E2%80%9C%E5%A4%B1%E6%95%88%E2%80%9D.html"},{default:l(()=>[a("PGSQL GIN索引“失效”")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:l(()=>[a("批量修改git历史记录中的用户名和邮箱")]),_:1})]),e("li",null,[t(i,{to:"/software/shodowsocks/ShadowsockServer%E9%85%8D%E7%BD%AE.html"},{default:l(()=>[a("ShadowsockServer配置")]),_:1})]),e("li",null,[t(i,{to:"/software/java-basic/%E4%B8%8D%E9%87%8D%E5%90%AF%20JVM%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E6%8E%89%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%EF%BC%9F.html"},{default:l(()=>[a("不重启 JVM，如何替换掉已经加载的类？")]),_:1})]),e("li",null,[t(i,{to:"/software/jvm/JVM%E6%9D%82%E9%A1%B9.html"},{default:l(()=>[a("JVM杂项")]),_:1})]),e("li",null,[t(i,{to:"/other/Git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:l(()=>[a("Git历史记录修改用户名和邮箱")]),_:1})]),e("li",null,[t(i,{to:"/other/Mermaid%E7%A4%BA%E4%BE%8B.html"},{default:l(()=>[a("Mermaid示例")]),_:1})])]),p,E,u,B])}const x=r(s,[["render",m],["__file","MySQL杂项.html.vue"]]);export{x as default};
