import{_ as o,$ as l,a0 as r,a1 as e,a3 as n,a4 as t,a5 as s,a2 as a,w as p}from"./framework-b3a0f150.js";const d={},c=s(`<h2 id="如何解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#如何解决循环依赖的" aria-hidden="true">#</a> 如何解决循环依赖的</h2><p>先说网上流程很广的所谓的三级缓存吧 <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758835364709600.png" alt="" loading="lazy"> 总之就是三个map。</p><p>假设A依赖B，B依赖A（非构造器互相依赖，构造器互相依赖无法解决） spring先创建a，然后把自己放到三级缓存中，然后进行依赖注入，发现依赖b,然后分别去一级、二级、三级缓存中找，都没找到 于是spring接着创建b，spring把b先new出来，然后把自己放入三级缓存中，然后进行依赖注入，发现依赖a，于是分别去一级、二级 三级缓存中找，结果在三级缓存中找到a，于是把a从三级缓存中移除并把a放到二级缓存中。然后b的依赖注入顺利完成，b创建成功，于是把自己从三级缓存中移除，放到一级缓存中。 然后回过了头接着对a进行依赖注入，然后再次从三个缓存中找，结果在一级缓存中找到了b，完成依赖注入，a创建完成，并把二级缓存中 移除，然后把自己放入一级缓存。</p><p>上面是网上广为流传的说法，这个说法我不是很赞同哈。</p><p>不赞同的点不是这个流程，这个流程应该和代码的相差不大，我不赞同的是我觉得这个说法夸大了所谓的缓存的作用，给人的感觉是因为三级缓存解决了循环依赖</p><p>实际不用三级，就用一个map也能搞定。因为只要能new出来，那么就能先能先让其他bean先引用</p><h2 id="beanfactory与factorybean的区别" tabindex="-1"><a class="header-anchor" href="#beanfactory与factorybean的区别" aria-hidden="true">#</a> BeanFactory与FactoryBean的区别</h2><p>看名字知道，BeanFactory是个bean工厂，也就是来生产bean的，由他生产的bean会经过spring的生命周期， 比如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>populateBean
initilaizeBean
    invokeAwareMethods
    applyBeanPostProcessorsBeforeInitialization
    invokeInitMethods
        InitializingBean#afterPropertiesSet
        自定义的init方法
    applyBeanPostProcessorsAfterInitialization
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后FactoryBean是一个bean， 他既是一个普通的bean,也不是一个普通的bean.</p><p>说他是普通bean，是因为他和我们平常写的controller，service等一样，创建factorybean的时候也会经过上面的生命周期。</p><p>说他不是普通的bean，是因为这个bean又可以通过调用getObject方法来创建bean并交给spring管理。但是通过这个方法创建的bean就不会经过上面的生命周期。 可以通过这种方式来创建第三方jar包里的实例对象。 <s>有点像我们平时用得@Bean注解一样</s>（@Bean注解创建的bean也会经过spring的生命周期）</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758683689872700.png" alt="" loading="lazy"></h2><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758694081149000.png" alt="" loading="lazy"></h2><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758714434336800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> spring事务</h2><p>按下面方式成对记忆</p><ol><li>REQUIRED， REQUIRED_NEW</li><li>SUPPORTS， NOT_SUPPORTED</li><li>MANDATORY， NEVER</li><li>NESTED</li></ol><h2 id="springbootapplication注解" tabindex="-1"><a class="header-anchor" href="#springbootapplication注解" aria-hidden="true">#</a> SpringBootApplication注解</h2><p>@SpringBootApplication可以看做下面三个注解的合集</p><ol><li><p>@Configuration</p><blockquote><p>允许在 Spring 上下文中注册额外的 bean 或导入其他配置类，用来标记当前类是一个配置类</p></blockquote></li><li><p>@ComponentScan</p><blockquote><p>扫描被@Component (@Repository,@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p></blockquote></li><li><p>@EnableAutoConfiguration</p><blockquote><p>启用 SpringBoot 的自动配置机制</p></blockquote></li></ol><p>重点说说 @EnableAutoConfiguration</p><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration</h3><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/771104096701700.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个注解上面有个import注解，import注解的使用看下文。 通过import注解导入了一个ImportSelector的实现类，类名想不起来了 我们知道如果导入的是一个ImportSelector的实现类，那么spring会执行里面的selectImports方法来得到需要创建 的bean的类全名。在这个实现类的这个方法里，会读取类路径下的spring.factories文件，这个文件就定义了各种普通类，配置类</p><p>总结：</p><ol><li><p>如果我们自己写了组件，想要给被人使用，就可以在jar包中添加spring.factories文件，并把相关的配置类写上去，这样其他人只需要吧 这个jar包放入类路径下即可</p></li><li><p>通过spring.factories文件的方式是不需要其他额外工作就可以激活相关功能的，我们还可以也写一个类似Enable的注解， 再这个注解上面加上Configuration注解，或者import注解，这样只要在启动类上加上这个注解就能激活相关功能</p></li></ol><h3 id="import注解" tabindex="-1"><a class="header-anchor" href="#import注解" aria-hidden="true">#</a> @Import注解</h3><p>可以导入几种类：</p><ol><li>普通类 <blockquote><p>这个情况会创建这个普通的实例</p></blockquote></li><li>ImportSelector实现类 <blockquote><p>如果导入的是这个类，就会执行这个类的importSelect方法，这个方法会返回需要创建的bean的类全名， 然后spring就会根据类全名创建bean</p></blockquote></li><li>ImportBeanDefinitionRegistrar实现类 <blockquote><p>导入这种类型的类，就会执行这个类的registerBeanDefinitions方法， 可以在这个方法里定义BeanDefinition并进行注册，这样spring就能根据 BeanDefinition来创建bean</p></blockquote></li></ol><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,32),E=e("p",null,[e("br"),e("br"),e("br"),e("br"),e("br"),e("br")],-1),u=e("hr",null,null,-1),h=e("hr",null,null,-1),b=e("ul",null,[e("li",null,[e("strong",null,"随机毒鸡汤"),a("：小时候总骗爸妈我没钱了，现在总骗爸妈，没事我还有钱。 "),e("br"),e("br"),e("img",{src:"https://tuapi.eees.cc/api.php?category=biying&type=302&uuid=25764f64-9d6b-4b7c-9542-e523a65f6c52",alt:"",loading:"lazy"})])],-1);function B(m,g){const i=p("RouterLink");return l(),r("div",null,[c,e("ul",null,[e("li",null,[n(i,{to:"/software/unclassified/MAT%E5%B7%A5%E5%85%B7.html"},{default:t(()=>[a("MAT工具")]),_:1})]),e("li",null,[n(i,{to:"/software/unclassified/NGINX.html"},{default:t(()=>[a("NGINX")]),_:1})]),e("li",null,[n(i,{to:"/software/middleware/es/ES6.2.3(3%E8%8A%82%E7%82%B9)%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%88%B0ES7.4.1(5%E8%8A%82%E7%82%B9).html"},{default:t(()=>[a("ES6.2.3(3节点)数据迁移到ES7.4.1(5节点)")]),_:1})]),e("li",null,[n(i,{to:"/other/%E9%9A%8F%E8%AE%B0.html"},{default:t(()=>[a("随记")]),_:1})]),e("li",null,[n(i,{to:"/other/Censys%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0.html"},{default:t(()=>[a("Censys搜索引擎学习")]),_:1})]),e("li",null,[n(i,{to:"/other/Redis%E9%AB%98%E5%8F%AF%E7%94%A8.html"},{default:t(()=>[a("Redis高可用")]),_:1})]),e("li",null,[n(i,{to:"/software/unclassified/PasteImageIntoMarkdown%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html"},{default:t(()=>[a("PasteImageIntoMarkdown插件开发")]),_:1})]),e("li",null,[n(i,{to:"/software/unclassified/%E5%A4%9A%E5%8F%B0centos%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%A4%87%E4%BB%BD.html"},{default:t(()=>[a("多台centos服务器，文件互相备份")]),_:1})]),e("li",null,[n(i,{to:"/other/MyBatis%20xml%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86.html"},{default:t(()=>[a("MyBatis xml特殊字符处理")]),_:1})]),e("li",null,[n(i,{to:"/software/java-basic/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html"},{default:t(()=>[a("CountDownLatch源码解读")]),_:1})]),e("li",null,[n(i,{to:"/other/%E5%85%8D%E8%B4%B9%20API%20%E6%AF%8F%E6%97%A5%E6%8F%90%E4%BE%9B%E6%91%B8%E9%B1%BC%E6%97%A5%E6%8A%A5%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%97%A0%E6%B0%B4%E5%8D%B0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"},{default:t(()=>[a("免费 API 每日提供摸鱼日报，自动返回无水印图片，适用于公众号和小程序")]),_:1})]),e("li",null,[n(i,{to:"/other/PostgreSQL%E9%AB%98%E5%8F%AF%E7%94%A8.html"},{default:t(()=>[a("PostgreSQL高可用")]),_:1})])]),E,u,h,b])}const A=o(d,[["render",B],["__file","常见问题.html.vue"]]);export{A as default};
