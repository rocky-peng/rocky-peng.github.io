import{_ as a,$ as e,a0 as i,a3 as n}from"./framework-e876a0da.js";const t={},o=n(`<h2 id="如何解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#如何解决循环依赖的" aria-hidden="true">#</a> 如何解决循环依赖的</h2><p>先说网上流程很广的所谓的三级缓存吧 <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758835364709600.png" alt="" loading="lazy"> 总之就是三个map。</p><p>假设A依赖B，B依赖A（非构造器互相依赖，构造器互相依赖无法解决） spring先创建a，然后把自己放到三级缓存中，然后进行依赖注入，发现依赖b,然后分别去一级、二级、三级缓存中找，都没找到 于是spring接着创建b，spring把b先new出来，然后把自己放入三级缓存中，然后进行依赖注入，发现依赖a，于是分别去一级、二级 三级缓存中找，结果在三级缓存中找到a，于是把a从三级缓存中移除并把a放到二级缓存中。然后b的依赖注入顺利完成，b创建成功，于是把自己从三级缓存中移除，放到一级缓存中。 然后回过了头接着对a进行依赖注入，然后再次从三个缓存中找，结果在一级缓存中找到了b，完成依赖注入，a创建完成，并把二级缓存中 移除，然后把自己放入一级缓存。</p><p>上面是网上广为流传的说法，这个说法我不是很赞同哈。</p><p>不赞同的点不是这个流程，这个流程应该和代码的相差不大，我不赞同的是我觉得这个说法夸大了所谓的缓存的作用，给人的感觉是因为三级缓存解决了循环依赖</p><p>实际不用三级，就用一个map也能搞定。因为只要能new出来，那么就能先能先让其他bean先引用</p><h2 id="beanfactory与factorybean的区别" tabindex="-1"><a class="header-anchor" href="#beanfactory与factorybean的区别" aria-hidden="true">#</a> BeanFactory与FactoryBean的区别</h2><p>看名字知道，BeanFactory是个bean工厂，也就是来生产bean的，由他生产的bean会经过spring的生命周期， 比如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>populateBean
initilaizeBean
    invokeAwareMethods
    applyBeanPostProcessorsBeforeInitialization
    invokeInitMethods
        InitializingBean#afterPropertiesSet
        自定义的init方法
    applyBeanPostProcessorsAfterInitialization
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后FactoryBean是一个bean， 他既是一个普通的bean,也不是一个普通的bean.</p><p>说他是普通bean，是因为他和我们平常写的controller，service等一样，创建factorybean的时候也会经过上面的生命周期。</p><p>说他不是普通的bean，是因为这个bean又可以通过调用getObject方法来创建bean并交给spring管理。但是通过这个方法创建的bean就不会经过上面的生命周期。 可以通过这种方式来创建第三方jar包里的实例对象。 <s>有点像我们平时用得@Bean注解一样</s>（@Bean注解创建的bean也会经过spring的生命周期）</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758683689872700.png" alt="" loading="lazy"></h2><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758694081149000.png" alt="" loading="lazy"></h2><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758714434336800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> spring事务</h2><p>按下面方式成对记忆</p><ol><li>REQUIRED， REQUIRED_NEW</li><li>SUPPORTS， NOT_SUPPORTED</li><li>MANDATORY， NEVER</li><li>NESTED</li></ol><h2 id="springbootapplication注解" tabindex="-1"><a class="header-anchor" href="#springbootapplication注解" aria-hidden="true">#</a> SpringBootApplication注解</h2><p>@SpringBootApplication可以看做下面三个注解的合集</p><ol><li><p>@Configuration</p><blockquote><p>允许在 Spring 上下文中注册额外的 bean 或导入其他配置类，用来标记当前类是一个配置类</p></blockquote></li><li><p>@ComponentScan</p><blockquote><p>扫描被@Component (@Repository,@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p></blockquote></li><li><p>@EnableAutoConfiguration</p><blockquote><p>启用 SpringBoot 的自动配置机制</p></blockquote></li></ol><p>重点说说 @EnableAutoConfiguration</p><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration</h3><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/771104096701700.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个注解上面有个import注解，import注解的使用看下文。 通过import注解导入了一个ImportSelector的实现类，类名想不起来了 我们知道如果导入的是一个ImportSelector的实现类，那么spring会执行里面的selectImports方法来得到需要创建 的bean的类全名。在这个实现类的这个方法里，会读取类路径下的spring.factories文件，这个文件就定义了各种普通类，配置类</p><p>总结：</p><ol><li><p>如果我们自己写了组件，想要给被人使用，就可以在jar包中添加spring.factories文件，并把相关的配置类写上去，这样其他人只需要吧 这个jar包放入类路径下即可</p></li><li><p>通过spring.factories文件的方式是不需要其他额外工作就可以激活相关功能的，我们还可以也写一个类似Enable的注解， 再这个注解上面加上Configuration注解，或者import注解，这样只要在启动类上加上这个注解就能激活相关功能</p></li></ol><h3 id="import注解" tabindex="-1"><a class="header-anchor" href="#import注解" aria-hidden="true">#</a> @Import注解</h3><p>可以导入几种类：</p><ol><li>普通类 <blockquote><p>这个情况会创建这个普通的实例</p></blockquote></li><li>ImportSelector实现类 <blockquote><p>如果导入的是这个类，就会执行这个类的importSelect方法，这个方法会返回需要创建的bean的类全名， 然后spring就会根据类全名创建bean</p></blockquote></li><li>ImportBeanDefinitionRegistrar实现类 <blockquote><p>导入这种类型的类，就会执行这个类的registerBeanDefinitions方法， 可以在这个方法里定义BeanDefinition并进行注册，这样spring就能根据 BeanDefinition来创建bean</p></blockquote></li></ol><p><br><br><br><br><br><br></p><hr><hr><ul><li><strong>随机毒鸡汤</strong>：不是我不合群，只是我合群的人，没有你而已。 <br><br><img src="https://tuapi.eees.cc/api.php?category=fengjing&amp;type=302&amp;uuid=77942a11-3d43-4a0b-8af7-41d1a09f63f1" alt="" loading="lazy"></li></ul>`,34),r=[o];function p(l,s){return e(),i("div",null,r)}const d=a(t,[["render",p],["__file","常见问题.html.vue"]]);export{d as default};
