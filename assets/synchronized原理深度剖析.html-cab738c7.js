import{_ as t,$ as l,a0 as r,a1 as a,a3 as s,a4 as i,a5 as o,a2 as e,w as d}from"./framework-b3a0f150.js";const c={},p=o(`<p>sync是jvm的内置锁，底层是通过对象监视器(ObjectMonitor)来实现。而对象监视器的底层实现是通过<strong>cas+自旋</strong>或者<strong>操作系统的互斥量</strong>来实现的。通过javap -c 命令可以查看到sync方法前后有成对的monitorenter/monitorexit指令。</p><p>ObjectMonitor的结构 <img src="https://cdn.justdopay.top/xiaoshujiang/1629079090127.png" alt="" loading="lazy"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>cas<span class="token operator">:</span> compare and swap ，比对并交换。
这个操作是cpu指令级的功能，可以保证原子性。
这个操作需要三个参数：<span class="token number">1.</span>数据存放的地址<span class="token class-name">Addr</span>  <span class="token number">2.</span>原来的值<span class="token class-name">A</span>  <span class="token number">3.</span>期望改变后的值<span class="token class-name">B</span>。
只有当<span class="token class-name">Addr</span>数据为<span class="token class-name">A</span>的时候才会成功把值更改为<span class="token class-name">B</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cas的三大问题" tabindex="-1"><a class="header-anchor" href="#cas的三大问题" aria-hidden="true">#</a> CAS的三大问题</h2><ul><li><p>ABA问题</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cas的ABA问题: 描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。
这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，
最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，
所以 compareAndSet 操作是成功。 这在某些场景是不允许的

一个不恰当的例子：公司有一笔专款专用的钱100万，在公司真正支出这笔钱之前，公司财务挪用这笔钱借给了自己的某个朋友，
然后这个朋友归还了回来。归还之后公司正常使用了这笔钱，表面上对公司没有任何影响，但挪用公款这个行为是违法不允许的。

如何解决这个问题：增加一个版本号。 Java中的AtomicStampedReference通过版本号解决了这个问题。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>循环时间长开销大</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>一般cas都会配合一个循环来使用，所以如果cas长时间不成功，是很消耗cpu的。所以一般还要配合LockSurport.park使用
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>只能保证一个变量的原子操作</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>可以把多个变量封装在一个对象里，然后通过AtomicReference来进行操作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><p>在jvm早期中，sync是通过操作系统的互斥量来实现的，这就会涉及到操作系统的用户态和内核态的切换，这是非常消耗系统资源的操作。所以后来引入了轻量级锁，即通过cas+自旋的方式来实现。</p><p>那么执行同步代码块的线程是如何进行同步的呢？它们总有一个共同的存储锁信息的地方吧？ 是的，那就是对象的<strong>mark word</strong>（上图ObjectMonitor中的_header字段）。</p><p>对象的mark word在什么地方呢？ 在对象的对象头里。这里扩展下对象在jvm中的内存结构：</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079098757.png" alt="对象结构" tabindex="0" loading="lazy"><figcaption>对象结构</figcaption></figure><p>我们重点关注下对象头中的mark word，那么mark word的结构又是怎样的呢？32位jvm中如下： <img src="https://cdn.justdopay.top/xiaoshujiang/1629079105518.png" alt="mark word结构" loading="lazy"></p><p>线程就是通过对象的mark word来进行同步的。</p><p>在上图可以看到mark word中记录了对象锁的状态，分为无锁、偏向锁、轻量级锁、重量级锁。这几种状态的转变规则为无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，这个规则称之为锁的升级。<strong>注意：锁只能升级不能降级。但偏向锁可以降级为无锁，其他的不行。</strong></p><h2 id="锁的升级过程" tabindex="-1"><a class="header-anchor" href="#锁的升级过程" aria-hidden="true">#</a> 锁的升级过程</h2><p>见图：</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079120186.png" alt="sync锁的升级过程" tabindex="0" loading="lazy"><figcaption>sync锁的升级过程</figcaption></figure><p>这张图用文字描述清楚感觉太费劲，文字还多，说不定吃力不讨好，所以这个图要慢慢品，细细品，多次品。品的时候建议假设有多个线程在竞争锁。</p><p>品的时候有个难点可能是偏向锁的撤销那，<strong>偏向锁的撤销是在有锁竞争的情况下才会撤销</strong>。为什么呢 ？我们优先要明白偏向锁的设计目的是什么？ 因为可能存在这种情况：这个同步代码块只有一个线程在访问。如果没有偏向锁，那么根据上图这个线程会多次进行cas操作，这个显然是没有必要的，于是为了优化就设计了偏向锁。使得在只有一个线程访问同步代码块的时候，只需要比对之前偏向的线程是不是自己，如果是，则获得锁。</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h2><p>sync的对象不要使用String Integer Long等基础对象，因为这些对象存在缓存原因，可能锁到其他线程用的对象。</p><h2 id="sync和reentrantlock的区别" tabindex="-1"><a class="header-anchor" href="#sync和reentrantlock的区别" aria-hidden="true">#</a> sync和ReentrantLock的区别</h2><ol><li>两者都是可重入的（sync的重入次数保存在哪里的呢？）</li><li>sync是基于jvm实现的，是隐式锁，而ReentrantLock是基于java api实现的，是显式锁。</li><li>ReentrantLock 比 synchronized 更加灵活 <ol><li>可以试探性获得锁（tryLock）</li><li>等待可中断；(acquireInterruptibly)</li><li>可实现公平锁，sync是非公平的</li><li>可实现选择性通知，也就是可以创建多个条件队列</li><li>性能上已经不是一个选择因素了。sync做了各种优化（偏向锁、自旋锁、锁粗化、锁消除等等）</li></ol></li></ol><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><h3 id="矛盾1" tabindex="-1"><a class="header-anchor" href="#矛盾1" aria-hidden="true">#</a> 矛盾1</h3><p>A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p><p>B: 锁大多数情况都是在很短的时间执行完成。</p><p>解决方案: 引入轻量锁(通过自旋来完成锁竞争)。</p><h3 id="矛盾2" tabindex="-1"><a class="header-anchor" href="#矛盾2" aria-hidden="true">#</a> 矛盾2</h3><p>A: 轻量级锁中的自旋: 占用CPU时间，增加CPU的消耗(因此在多核处理器上优势更明显)。</p><p>B: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源。</p><p>解决方案: JDK5中引入默认自旋次数为10(用户可以通过-XX:PreBlockSpin进行修改)， JDK6中更是引入了自适应自旋（简单来说如果自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁，实际场景中，HotSpot认为最佳时间应该是一个线程上下文切换的时间，而是否自旋以及自旋次数更是与对CPUs的负载、CPUs是否处于节电模式等息息相关的)。</p><h3 id="矛盾3" tabindex="-1"><a class="header-anchor" href="#矛盾3" aria-hidden="true">#</a> 矛盾3</h3><p>A: 项目中代码块中可能绝大情况下都是多线程访问。</p><p>B: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少。</p><p>解决方案: 可以使用-XX:-UseBiasedLocking=false禁用偏向锁。</p><h3 id="矛盾4" tabindex="-1"><a class="header-anchor" href="#矛盾4" aria-hidden="true">#</a> 矛盾4</h3><p>A: 代码中JDK原生或其他的工具方法中带有大量的加锁。</p><p>B: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)。</p><p>解决方法: 引入<strong>锁削除</strong>(虚拟机即时编译器(JIT)运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)。</p><h3 id="矛盾5" tabindex="-1"><a class="header-anchor" href="#矛盾5" aria-hidden="true">#</a> 矛盾5</h3><p>A: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对同一对象加锁。</p><p>B: 由于在频繁的执行中，反复的加锁和解锁，这种频繁的锁竞争带来很大的性能损耗。</p><p>解决方法: 引入<strong>锁扩大/锁膨胀</strong>(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在它们外部)。</p><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,44),h=a("p",null,[a("br"),a("br"),a("br"),a("br"),a("br"),a("br")],-1),u=a("hr",null,null,-1),m=a("hr",null,null,-1),E=a("ul",null,[a("li",null,[a("strong",null,"随机毒鸡汤"),e("：为什么秀恩爱，通常要选择在中午？因为早晚都会遭报应。 "),a("br"),a("br"),a("img",{src:"https://images.pexels.com/photos/30865750/pexels-photo-30865750.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"Professional equestrian holding a horse with a rider atop, poised in modern riding gear outdoors.",loading:"lazy"})])],-1);function g(v,B){const n=d("RouterLink");return l(),r("div",null,[p,a("ul",null,[a("li",null,[s(n,{to:"/software/unclassified/MAT%E5%B7%A5%E5%85%B7.html"},{default:i(()=>[e("MAT工具")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/%E5%90%84%E7%A7%8D%E7%BD%91%E5%85%B3%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"},{default:i(()=>[e("各种网关性能测试")]),_:1})]),a("li",null,[s(n,{to:"/other/JetBrains%20IDE%20%E5%85%A8%E7%A0%B4%E8%A7%A3.html"},{default:i(()=>[e("JetBrains IDE 全破解")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/PasteImageIntoMarkdown%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html"},{default:i(()=>[e("PasteImageIntoMarkdown插件开发")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:i(()=>[e("批量修改git历史记录中的用户名和邮箱")]),_:1})]),a("li",null,[s(n,{to:"/other/Spring%20Boot%E5%8D%87%E7%BA%A7%E5%88%B02%206%20x%E8%B8%A9%E7%9A%84%E5%9D%91.html"},{default:i(()=>[e("Spring Boot升级到2 6 x踩的坑")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/gperftools.html"},{default:i(()=>[e("gperftools")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/%E5%88%B6%E4%BD%9CKVM%20ES%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.html"},{default:i(()=>[e("制作KVM ES镜像文件")]),_:1})]),a("li",null,[s(n,{to:"/software/shodowsocks/ShadowsockServer%E9%85%8D%E7%BD%AE.html"},{default:i(()=>[e("ShadowsockServer配置")]),_:1})]),a("li",null,[s(n,{to:"/software/middleware/mysql/SQL%E4%BC%98%E5%8C%96.html"},{default:i(()=>[e("SQL优化")]),_:1})]),a("li",null,[s(n,{to:"/other/Git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:i(()=>[e("Git历史记录修改用户名和邮箱")]),_:1})]),a("li",null,[s(n,{to:"/other/vuepress-theme-hope%20%E6%B7%BB%E5%8A%A0%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A.html"},{default:i(()=>[e("vuepress-theme-hope 添加谷歌广告")]),_:1})])]),h,u,m,E])}const b=t(c,[["render",g],["__file","synchronized原理深度剖析.html.vue"]]);export{b as default};
