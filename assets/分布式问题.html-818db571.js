import{_ as d,$ as s,a0 as h,a1 as l,a2 as e,a3 as a,a4 as t,a5 as r,w as o}from"./framework-16d560c6.js";const c={},u=r('<h2 id="熔断" tabindex="-1"><a class="header-anchor" href="#熔断" aria-hidden="true">#</a> 熔断</h2><p>个人感觉在语音上对熔断和降级的说明有些重合，或者不容易区分</p><p>当扇出链路的某个微服务不可用或者响应太长时，熔断(或者中断)该节点微服务的调用，快速返回错误的响应信息</p><p>熔断的目的是当A服务模块中的某块程序出现故障后为了不影响其他客户端的请求而做出的及时回应。</p><p>直接看例子 <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/666832440022300.png" alt="" loading="lazy"></p><p>最底部的熔断方法和服务主体是跑在一起的</p><h2 id="降级" tabindex="-1"><a class="header-anchor" href="#降级" aria-hidden="true">#</a> 降级</h2><p>降级的目的是为了解决整体项目的压力，而牺牲掉某一服务模块而采取的措施。</p><p><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/667178740923000.png" alt="" loading="lazy"><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/667187558566600.png" alt="" loading="lazy"></p><ol><li>降级的代码是在调用端跑的（当被调用端的服务由于资源不够等原因被停止时，上游调用端也能得到一个相对正常的响应）</li><li>熔断的代码是在被调用端跑的（当某个服务或接口超过频率或者触发其他规则时，进行的某些动作）</li></ol><p>也许这就是最能说明两者区别的区别</p>',11),p={href:"https://sentinelguard.io/zh-cn/",target:"_blank",rel:"noopener noreferrer"},f=l("p",null,"sentinel提供了熔断、流量整形等各种灵活功能",-1),_={id:"阿里巴巴的sentinel框架",tabindex:"-1"},m=l("a",{class:"header-anchor",href:"#阿里巴巴的sentinel框架","aria-hidden":"true"},"#",-1),E={href:"https://sentinelguard.io/zh-cn/",target:"_blank",rel:"noopener noreferrer"},g=r('<figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/669888581011800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在管理后台可以定义目标、应用什么规则(策略)、触发后采取的措施</p><p>可以这样使用： <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/685805540452400.png" alt="" loading="lazy"></p><p>也可以： <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-15/685952895529900.png" alt="" loading="lazy"></p><h2 id="网关" tabindex="-1"><a class="header-anchor" href="#网关" aria-hidden="true">#</a> 网关</h2><h3 id="java生态的网关" tabindex="-1"><a class="header-anchor" href="#java生态的网关" aria-hidden="true">#</a> JAVA生态的网关</h3><ol><li>Zuul <blockquote><p>兼容servlet，学习成本比gateway低一些，但性能比gateway要差</p></blockquote></li><li>Spring Cloud Gateway <blockquote><p>和servlet不兼容，底层通信采用的netty，基于webflux开发，有一定的学习成本，但性能比zuul好很多</p></blockquote></li></ol><h3 id="云原生网关" tabindex="-1"><a class="header-anchor" href="#云原生网关" aria-hidden="true">#</a> 云原生网关</h3><ol><li>nginx家族(nginx/openresty/kong) <blockquote><p>之前尝试过nginx/openresty，但学习成本相对高，最后自己通过filter写了一套代码来达到目的</p></blockquote></li><li>apisix <blockquote><p>国内开源项目，已从apache毕业，很多大厂也在使用，具体还没使用过，有提供方便管理的界面，这个很吸引人</p></blockquote></li></ol><h2 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> Zookeeper</h2><ol><li>可以理解为是一个分布式文件系统，满足CAP中的CP，在进行leader选举的时候不满足A</li><li>基于内存，所以性能很高，非常使用读多写少的场景。</li><li>针对写多读少的场景，zk存在一些性能瓶颈，因为它要把数据同步到其他zk节点上</li><li>分为4种节点，每个节点存储的数据大小限制为1M <ul><li>永久节点：即便zk宕机也还在，直到删除</li><li>永久顺序节点：</li><li>临时节点：和会话绑定，会话消失节点消失，只能是叶子节点，不能有子节点</li><li>临时顺序节点：除了临时节点的特性外，节点名称还具有顺序性</li></ul></li><li>节点间通过zab协议保持数据同步</li><li>会有脑裂问题，也就是可能同时存在两个leader，但由于有过半机制，所以只能一个leader能提供写服务，所以也可以说没有脑裂问题。</li><li>节点有三种角色(raft协议也是三种角色) <ul><li>leader</li><li>follower</li><li>observer</li></ul></li><li>为啥节点数最好奇数个，因为2n个节点和2n-1个节点的容忍度一样，比如4台最多宕机一台，3台也是最多宕机一台</li><li>zab协议，这个没去研究了，研究了下更简单易懂的raft协议</li></ol><h2 id="如何设计一个高可用系统" tabindex="-1"><a class="header-anchor" href="#如何设计一个高可用系统" aria-hidden="true">#</a> 如何设计一个高可用系统？</h2><p>个人认为这个问题有点大，因为一个系统往往是由很多子系统或者组件构成，要整个系统高可用，那么冲请求进来到请求返回的整个链路都要高可用才行。 总的来说分几个层来说吧：</p><ol><li>存储层</li><li>各种中间件</li><li>代码层(服务层)</li><li>网关层</li><li>监控系统、动态扩容</li><li>操作系统层</li><li>cdn，dns等等</li></ol><h3 id="存储层高可用" tabindex="-1"><a class="header-anchor" href="#存储层高可用" aria-hidden="true">#</a> 存储层高可用</h3><p>不同的存储又有不同的高可用</p><ol><li>mysql：尽量sql简单，全表查询，慢查询，利用好索引等等因素，还可以做异地备份，异地双活这些，分库分表呀等等</li><li>es：合适的分词器，副本的设置，分片的设置，每条消息大小的限制等等</li></ol><h3 id="各种中间件" tabindex="-1"><a class="header-anchor" href="#各种中间件" aria-hidden="true">#</a> 各种中间件</h3><ul><li>比如redis高可用方案，个人比较喜欢codis: <ol><li>codis</li><li>redis本身的cluser方案，同时redis自身的各种设置，比如持久化规则，aof重写，内存淘汰策略等等</li><li>twitter的Twemproxy</li></ol></li><li>mq的高可用，不同的mq又有不同的方案</li></ul><h3 id="代码层-服务层" tabindex="-1"><a class="header-anchor" href="#代码层-服务层" aria-hidden="true">#</a> 代码层(服务层)</h3><ol><li>自身代码逻辑要处理好，避免出现一些OOM，cpu飙高等问题</li><li>比如数据库连接池呀，锁呀，分布式锁呀，等等很多小的问题在大流量下都可能放大为导火索</li><li>缓存呀</li></ol><h3 id="网关层" tabindex="-1"><a class="header-anchor" href="#网关层" aria-hidden="true">#</a> 网关层</h3><ol><li>限流熔断呀，非法请求识别与拦截呀，限流算法呀，如何实现，是用云原生还是服务网关呀等等</li></ol><h3 id="操作系统层" tabindex="-1"><a class="header-anchor" href="#操作系统层" aria-hidden="true">#</a> 操作系统层</h3><ol><li>比如单进程打开的文件数，tcp握手挥手相关参数设置</li></ol><h3 id="cdn和dns" tabindex="-1"><a class="header-anchor" href="#cdn和dns" aria-hidden="true">#</a> cdn和dns</h3><ol><li>比如cdn，图片大小，上次西安还是哪个地方的类似渝康码的东西就蹦了斗嘛，主要就是没有图片原因样</li><li>dns也能达到分流的目的这些</li></ol><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>',29),b=l("p",null,[l("br"),l("br"),l("br"),l("br"),l("br"),l("br")],-1),x=l("hr",null,null,-1),B=l("hr",null,null,-1),k=l("ul",null,[l("li",null,[l("strong",null,"随机毒鸡汤"),e("：别跟傻瓜吵架，不然旁人会搞不清楚，到底谁是傻瓜。 "),l("br"),l("br"),l("img",{src:"https://tuapi.eees.cc/api.php?category=biying&type=302&uuid=2859e0ff-3faa-4f2b-8feb-7bfa0de495f7",alt:"",loading:"lazy"})])],-1);function w(A,y){const n=o("ExternalLinkIcon"),i=o("RouterLink");return s(),h("div",null,[u,l("p",null,[e("现在熔断的依赖包hystrix现在已经没人维护了，所以不推荐使用，个人更推荐使用**"),l("a",p,[e("阿里巴巴的sentinel框架"),a(n)]),e("**")]),f,l("h2",_,[m,e(),l("a",E,[e("阿里巴巴的sentinel框架"),a(n)])]),g,l("ul",null,[l("li",null,[a(i,{to:"/software/unclassified/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html"},{default:t(()=>[e("记一次内存泄漏")]),_:1})]),l("li",null,[a(i,{to:"/software/spring/Spring%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%85%B3%E9%94%AE%E7%82%B9.html"},{default:t(()=>[e("Spring框架源码关键点")]),_:1})]),l("li",null,[a(i,{to:"/software/java-basic/IO%E7%9B%B8%E5%85%B3.html"},{default:t(()=>[e("IO相关")]),_:1})]),l("li",null,[a(i,{to:"/software/middleware/mq/kafka.html"},{default:t(()=>[e("kafka")]),_:1})]),l("li",null,[a(i,{to:"/software/middleware/mysql/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html"},{default:t(()=>[e("分库分表")]),_:1})]),l("li",null,[a(i,{to:"/software/unclassified/index%E6%96%B9%E6%B3%95%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95.html"},{default:t(()=>[e("index方法压力测试记录")]),_:1})]),l("li",null,[a(i,{to:"/software/unclassified/gperftools.html"},{default:t(()=>[e("gperftools")]),_:1})]),l("li",null,[a(i,{to:"/software/java-basic/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html"},{default:t(()=>[e("CountDownLatch源码解读")]),_:1})]),l("li",null,[a(i,{to:"/software/middleware/mysql/SQL%E4%BC%98%E5%8C%96.html"},{default:t(()=>[e("SQL优化")]),_:1})]),l("li",null,[a(i,{to:"/other/PostgreSQL%20JSON%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"},{default:t(()=>[e("PostgreSQL JSON类型字段常用操作")]),_:1})]),l("li",null,[a(i,{to:"/software/raft/raft%E5%8D%8F%E8%AE%AE.html"},{default:t(()=>[e("raft协议")]),_:1})]),l("li",null,[a(i,{to:"/software/linux/Linux.html"},{default:t(()=>[e("Linux")]),_:1})])]),b,x,B,k])}const q=d(c,[["render",w],["__file","分布式问题.html.vue"]]);export{q as default};
