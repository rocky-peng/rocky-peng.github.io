import{_ as i,$ as p,a0 as c,a1 as a,a2 as e,a3 as s,a4 as t,a5 as l,w as r}from"./framework-349591b1.js";const d={},h=l(`<h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h2><h3 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h3><h3 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h3><h3 id="aof重写" tabindex="-1"><a class="header-anchor" href="#aof重写" aria-hidden="true">#</a> AOF重写</h3><ol><li>cow机制(copy on write)</li><li>从7.0.0开始，aof文件分为base file和增量file.</li></ol><figure><img src="https://cdn.justdopay.top/notion/md5-f37f0cf7d53e518ed4c2762308ecac43.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><ol><li>从7.0.0开始，当开始执行aof rewrite的时候，主进程就会往一个新的增量aof文件写入数据，同时子进程就会依照现在内存中的数据创建一个新的base file。当子进程完成aof rewrite后，redis会进行一个原子操作使得新的base file生效。 <strong>感觉7.0.0的重写过程比之前的过程简单直接有效多了</strong></li></ol><figure><img src="https://cdn.justdopay.top/notion/md5-7f046cf7beb2fbc2321bf7c20d616fb2.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><p>重写过程总结：</p><ul><li><p>版本&gt;= 7.0</p><ol><li>fork一个子进程</li><li>主进程开始往新的一个增量aof文件中写入数据</li><li>子进程根据当前内存的数据生成一个新的base file</li><li>如果重写失败，原来的base file和原来的增量文件以及新的增量文件仍能代表当前数据的状态</li><li>如果重写成功，主进程会收到一个signal，然后通过一个原子操作使得新的base file和新的增量文件生效</li><li>清除之前的base file以及失效的增量文件</li></ol><figure><img src="https://cdn.justdopay.top/notion/md5-2afe9f1fa0a204b7d2004af6ac0f7bac.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure></li><li><p>版本&lt;7.0</p><ol><li>fork一个子进程</li><li>子进程开始根据当前内存数据生成一个新的aof文件</li><li>主进程会把这个期间收到的写命令写入一个缓冲区（当然也会同时写到aof缓存，和之前的动作一致）</li><li>如果子进程重写失败，当前正在使用的aof文件也能正常使用，所以安全</li><li>如果重写成功，主进程会把之前累计的缓冲区内容追加到新的aof文件中，然后原子的重命名aof文件</li></ol></li></ul><figure><img src="https://cdn.justdopay.top/notion/md5-c847f7d9982385c4ec54686caf6b788f.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><h2 id="主从架构" tabindex="-1"><a class="header-anchor" href="#主从架构" aria-hidden="true">#</a> 主从架构</h2><ol><li>主从架构可以实现读写分离，减轻master服务器的压力</li><li>但无法解决海量存储问题</li><li>无法做到高可用，一旦master宕机，无法自动failover</li></ol><h2 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h2><p>哨兵模式就是 <strong>监工+主从模式</strong> ，哨兵就是监工，监工的工作主要有以下3点：</p><ol><li><p>监控功能： 能监测集群内所有节点（包括master、slave以及其他哨兵节点）</p></li><li><p>故障转移：当master挂掉后，由哨兵节点来选举新的master节点并进行转移</p></li><li><p>配置中心：当故障转移发生后，通知client端新的master地址</p></li><li><p>哨兵节点数至少3个</p></li><li><p>哨兵模式只能保证高可用，并不能保证数据不丢失</p></li></ol><h3 id="为什么哨兵节点至少为3个" tabindex="-1"><a class="header-anchor" href="#为什么哨兵节点至少为3个" aria-hidden="true">#</a> 为什么哨兵节点至少为3个</h3><p>其实不一定，需要看具体怎么部署的，如果按照下面的方式进行部署：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>         <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token constant">M1</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span> <span class="token constant">R1</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token constant">S1</span> <span class="token operator">|</span>         <span class="token operator">|</span> <span class="token constant">S2</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>         <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>M1表示Master，R1表示从节点，S1，S2表示两个哨兵</p><p>此时，quorum为1，表示只要一个哨兵认为某个节点宕机了，就可以认为这个节点客观宕机了。同时 majority为2，表示至少需要两个哨兵的授权才能执行主备切换</p><p>如果此时m1宕机了（非m1所在服务器宕机），此时还有S1/S2都还活着，所以能正常执行主备切换</p><p>但如果m1所在服务器宕机，那么S1也宕机了，此时就只有S2这一个哨兵活着，自然不能执行主备切换</p><ul><li>quorum：需要多少哨兵都认为某个节点宕机时，这个节点才会被标记为客观宕机</li><li>majority：需要多少哨兵的授权才能执行主备切换（<strong>实际上去quorum和majority的较大值</strong>）</li></ul><h3 id="经典的-3-节点哨兵集群" tabindex="-1"><a class="header-anchor" href="#经典的-3-节点哨兵集群" aria-hidden="true">#</a> 经典的 3 节点哨兵集群</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>       <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
       <span class="token operator">|</span> <span class="token constant">M1</span> <span class="token operator">|</span>
       <span class="token operator">|</span> <span class="token constant">S1</span> <span class="token operator">|</span>
       <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
          <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token constant">R2</span> <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span> <span class="token constant">R3</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token constant">S2</span> <span class="token operator">|</span>         <span class="token operator">|</span> <span class="token constant">S3</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>         <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时：quorum 为 2，majority 为 2，所以如果m1所在的服务器宕机，那么还有两个哨兵节点，满足主备切换的哨兵数量要求</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="主观宕机" tabindex="-1"><a class="header-anchor" href="#主观宕机" aria-hidden="true">#</a> 主观宕机</h3><p>如果某个哨兵认为一个master宕机了，首先是主观宕机。</p><p>判定过程：哨兵会ping这个master，如果master在一个阈值时间内没有发送pong信息，那么这个哨兵就认为这个master主观宕机了</p><h3 id="客观宕机" tabindex="-1"><a class="header-anchor" href="#客观宕机" aria-hidden="true">#</a> 客观宕机</h3><p>如果quorum个哨兵都认为某个master主观宕机了，那么这个master就是客观宕机了</p><p>判定过程：当某个哨兵认为某个master主观宕机后，就会<code>~~通过gossip协议(没验证，应该不是这个协议，应该是通过pub/sub机制来完成通知)</code>~~ 通知其他哨兵。当某个哨兵在一定时间内收到quorum个哨兵也认为这个master主观宕机的消息，那么就会被标记为客观宕机</p><h3 id="哨兵自动发现机制" tabindex="-1"><a class="header-anchor" href="#哨兵自动发现机制" aria-hidden="true">#</a> 哨兵自动发现机制</h3><p>主要运用就是redis的pub/sub机制，具体过程如下：</p><p>每个哨兵会监听自己所监控的所有master/slave节点的 <code>__sentinel:hello__</code> 频道，同时每隔一段时间就会把自己的host、ip、runid、以及对这个节点的监控配置发送到这个频道，其他哨兵就会收到这个消息，从而自动发现其他哨兵</p><h3 id="主备切换大致过程" tabindex="-1"><a class="header-anchor" href="#主备切换大致过程" aria-hidden="true">#</a> 主备切换大致过程</h3><p>当quorum个哨兵认为某个master宕机后，并且majority个哨兵都同意进行主备切换，那么会从quorum个哨兵中选举一个哨兵来执行主备切换。会从所有的slave节点中选择一个slave成为master.</p><p>考虑的点有下面4个样子：</p><ol><li>和master断开连接的时长</li><li>slave的优先级（配置文件可以指定，越小优先级越高）</li><li>offset</li><li>runid</li></ol><p>slave过滤：如果某个slave与master断开连接的时长超过了一定阈值，那么这个slave就没有资格成为master</p><p>对过滤后的slave节点按照上面的2、3、4点进行排序，然后依次尝试进行切换</p><h3 id="版本号" tabindex="-1"><a class="header-anchor" href="#版本号" aria-hidden="true">#</a> 版本号</h3><p>执行主备切换过程中，会有个版本号，没太搞明白，这里贴出截图</p><figure><img src="https://cdn.justdopay.top/notion/md5-2df04897f02efab18deae69c738dac43.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><h2 id="redis-cluster" tabindex="-1"><a class="header-anchor" href="#redis-cluster" aria-hidden="true">#</a> Redis Cluster</h2>`,47),u={href:"https://redis.io/docs/reference/cluster-spec/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://redis.io/docs/management/scaling/",target:"_blank",rel:"noopener noreferrer"},m=a("figure",null,[a("img",{src:"https://cdn.justdopay.top/notion/md5-99d8f74041523458b6ca569e0dfaa3b6.png",alt:"Untitled",tabindex:"0",loading:"lazy"}),a("figcaption",null,"Untitled")],-1),k={href:"https://ieeexplore.ieee.org/document/6596860",target:"_blank",rel:"noopener noreferrer"},_=a("strong",null,"gossip",-1),b={href:"https://www.jianshu.com/p/54eab117e6ae",target:"_blank",rel:"noopener noreferrer"},g=a("li",null,"集群中每个节点都和其他节点保持连接，并发送各种信息包",-1),E=a("li",null,"集群并不能代理请求，所以客户端的情况有可能会被重定向，有点类似http的重定向，所以理论上客户端可以给集群中的任意节点发送请求。但为了提高性能，客户端可以缓存key和node的隐射关系",-1),v=a("li",null,"固定有2^14=16384个hash槽，每次采用crc16算法对key计算hash值，然后对16384取模得到某个hash槽，然后根据槽和节点的映射关系，最终路由到某个节点上",-1),x=a("li",null,"客户端可以通过hash tag的方式来让某个key的请求固定走某个hash槽",-1),B=a("li",null,"所有节点都各自持有一份元数据，如果发生变更，则通过gossip协议告知其他节点",-1),A=a("li",null,"比如3个master，每个master后面又挂多个slave",-1),y=l('<h3 id="jediscluster客户端工作过程" tabindex="-1"><a class="header-anchor" href="#jediscluster客户端工作过程" aria-hidden="true">#</a> JedisCluster客户端工作过程</h3><ol><li>每个jediscluster客户端都会在本地维护一个hash slot到node节点的隐射表</li><li>当对某个key执行操作的时候，会先在本地计算出这个key的crc16值，然后对2^14(16384)取模，得到hash slot，然后根据hash slot到node节点的隐射表，找到对应的node节点（可能正确，可能错误）。</li><li>然后对这个node节点发起请求，接收到请求的node节点发现这个slot恰好在自己这边，则执行请求。否则返回moved或ack</li><li>如果客户端收到moved请求，则更新本地的映射表，并重新发起请求。</li><li>如果客户端5次尝试都不成功，则报错</li></ol><h3 id="主备切换大致过程-1" tabindex="-1"><a class="header-anchor" href="#主备切换大致过程-1" aria-hidden="true">#</a> 主备切换大致过程</h3><p>其实过程和哨兵模式下的主备切换大致相同，都可以分为下面几步</p><ol><li><p>先标记客观宕机</p><p>如果一个节点认为某个master节点宕机了，则是主观宕机。</p><p>如果过半节点都认为这个master节点宕机了，则是客观宕机。（通过gossip协议通讯）</p></li><li><p>slave过滤</p><p>对宕机的master节点的所有从节点进行过滤</p><p>如果从节点与master节点的断开时间超过一定阈值，则这个从节点没有资格成为master节点</p></li><li><p>执行主备切换</p><p>对剩下的从节点进行排序，排序维度有 priority、offset、runid。然后依次尝试进行主备切换</p></li></ol><p><strong>备注：上面整理的内容对一些细节肯定是不对的，这里只是为了从整体上了解其中的原理或过程</strong></p><h2 id="twemproxy" tabindex="-1"><a class="header-anchor" href="#twemproxy" aria-hidden="true">#</a> Twemproxy</h2>',7),w={href:"https://github.com/twitter/twemproxy",target:"_blank",rel:"noopener noreferrer"},j=a("h2",{id:"codis-基本废弃了",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#codis-基本废弃了","aria-hidden":"true"},"#"),e(" Codis（基本废弃了）")],-1),S={href:"https://github.com/CodisLabs/codis",target:"_blank",rel:"noopener noreferrer"},D=a("h2",{id:"题外话",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#题外话","aria-hidden":"true"},"#"),e(" 题外话")],-1),F={href:"https://linux.die.net/man/2/",target:"_blank",rel:"noopener noreferrer"},C=a("p",null,"之前不理解什么section 2 ，看了上面的网页就明白了，原来Linux用户手册分为了好几部分，section 2就是第二部分，里面包含的是系统调用相关的介绍（为之前的愚蠢感到可笑 😂）",-1),U=a("ul",null,[a("li",null,[e("高可用的根部就是："),a("strong",null,"冗余 + 分片")]),a("li",null,"至于怎么实现冗余，那就不尽相同")],-1),M=a("br",null,null,-1),q=a("h2",{id:"系统推荐",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#系统推荐","aria-hidden":"true"},"#"),e(" 系统推荐")],-1),R=a("p",null,[a("br"),a("br"),a("br"),a("br"),a("br"),a("br")],-1),L=a("hr",null,null,-1),z=a("hr",null,null,-1),T=a("ul",null,[a("li",null,[a("strong",null,"随机毒鸡汤"),e("：别人知耻而后勇，我知耻而后怂。 "),a("br"),a("br"),a("img",{src:"https://images.pexels.com/photos/32150477/pexels-photo-32150477.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"Capture the tranquility of Mount Fuji reflected in a calm lake at twilight.",loading:"lazy"})])],-1);function V(I,N){const o=r("ExternalLinkIcon"),n=r("RouterLink");return p(),c("div",null,[h,a("p",null,[e("扩展阅读： "),a("a",u,[e("https://redis.io/docs/reference/cluster-spec/"),s(o)])]),a("p",null,[e("扩展阅读： "),a("a",f,[e("https://redis.io/docs/management/scaling/"),s(o)])]),m,a("ol",null,[a("li",null,[e("节点间通信没有采用普遍使用的tcp，而是"),a("a",k,[e("tcp-bus"),s(o)]),e("，是一种自组织网络")]),a("li",null,[e("节点间通信协议是 "),_,e(" 协议（"),a("a",b,[e("没去研究，说也是一种共识算法，模拟流行病的传播"),s(o)]),e("）")]),g,E,v,x,B,A]),y,a("p",null,[e("扩展阅读："),a("a",w,[e("https://github.com/twitter/twemproxy"),s(o)])]),j,a("p",null,[e("github都4年多没更新了 ， "),a("a",S,[e("https://github.com/CodisLabs/codis"),s(o)])]),D,a("p",null,[e("分享一个查看linux函数、系统调用的好网站： "),a("a",F,[e("https://linux.die.net/man/"),s(o)])]),C,U,M,q,a("ul",null,[a("li",null,[s(n,{to:"/software/unclassified/MyBatis.html"},{default:t(()=>[e("MyBatis")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/Oh%20My%20ZSH.html"},{default:t(()=>[e("Oh My ZSH")]),_:1})]),a("li",null,[s(n,{to:"/software/docker/Docker%E8%BF%9B%E8%A1%8C%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB.html"},{default:t(()=>[e("Docker进行资源隔离")]),_:1})]),a("li",null,[s(n,{to:"/software/jvm/JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.html"},{default:t(()=>[e("JVM参数设置")]),_:1})]),a("li",null,[s(n,{to:"/software/java-basic/Thread%20&%20ExecutorService%20&%20ThreadPoolExecutor%20%E6%80%BB%E8%A7%88.html"},{default:t(()=>[e("Thread & ExecutorService & ThreadPoolExecutor 总览")]),_:1})]),a("li",null,[s(n,{to:"/other/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.html"},{default:t(()=>[e("数据同步方案")]),_:1})]),a("li",null,[s(n,{to:"/software/middleware/mysql/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html"},{default:t(()=>[e("InnoDB存储引擎")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:t(()=>[e("批量修改git历史记录中的用户名和邮箱")]),_:1})]),a("li",null,[s(n,{to:"/software/unclassified/Flutter%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2.html"},{default:t(()=>[e("Flutter开发需要涉及的知识点大纲")]),_:1})]),a("li",null,[s(n,{to:"/software/shodowsocks/ShadowsockServer%E9%85%8D%E7%BD%AE.html"},{default:t(()=>[e("ShadowsockServer配置")]),_:1})]),a("li",null,[s(n,{to:"/other/Docker%E9%9A%90%E5%B0%84%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A4%96%E7%BD%91%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE.html"},{default:t(()=>[e("Docker隐射的端口外网不能访问")]),_:1})]),a("li",null,[s(n,{to:"/other/PostgreSQL%E9%AB%98%E5%8F%AF%E7%94%A8.html"},{default:t(()=>[e("PostgreSQL高可用")]),_:1})])]),R,L,z,T])}const P=i(d,[["render",V],["__file","Redis高可用.html.vue"]]);export{P as default};
