import{_ as l,$ as o,a0 as d,a1 as e,a2 as r,a3 as a,a4 as t,a5 as h,w as s}from"./framework-8c4427da.js";const c={},p=h(`<h2 id="cap-定理" tabindex="-1"><a class="header-anchor" href="#cap-定理" aria-hidden="true">#</a> CAP 定理</h2><ul><li><p>C—— 数据一致性，A—— 服务可用性，P—— 服务对网络分区故障的容错性。</p></li><li><p>这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。</p></li></ul><h3 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> Zookeeper</h3><p>Zookeeper 保证的是 CP，即任何时刻对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。从实际情况来分析，在使用 Zookeeper 获取服务列表时，如果 zookeeper 正在选主，或者 Zookeeper 集群中半数以上机器不可用，那么将就无法获得数据了。所以说，Zookeeper 不能保证服务可用性。</p><h3 id="zureka" tabindex="-1"><a class="header-anchor" href="#zureka" aria-hidden="true">#</a> Zureka</h3><p>Eureka 遵守的就是 AP 原则。在它的实现中，节点之间是相互平等的，部分注册中心的节点挂掉也不会对集群造成影响，即使集群只剩一个节点存活，也可以正常提供发现服务。</p><h3 id="consul" tabindex="-1"><a class="header-anchor" href="#consul" aria-hidden="true">#</a> Consul</h3><p><strong><code>Spring Cloud目前支持得最好的就是 Eureka，其次是 Consul，最后是 Zookeeper</code></strong></p><h2 id="netflix-和-spring-cloud的关系" tabindex="-1"><a class="header-anchor" href="#netflix-和-spring-cloud的关系" aria-hidden="true">#</a> Netflix 和 Spring Cloud的关系</h2><p>netflix 是一家互联网流媒体播放商巨头，拥有巨大的访问量。使得其对微服务架构下的方方面面都有涉猎，孵化出众多项目，最后开源给社区。Spring Cloud对其进行进一步封装，形成现在的spring cloud netflix众多子项目</p><h2 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka" aria-hidden="true">#</a> Eureka</h2><ol><li>Eureka Server就相当于 zk</li><li>Eureka Client可以分为两类：service provider / service consumer <ul><li>service consumer和service provider没有严格的界限，实际情况可能某个服务节点既是service consumer也是service provider.</li></ul></li></ol><p>三者的关系如下： <img src="https://cdn.justdopay.top/xiaoshujiang/1629079366803.png" alt="" loading="lazy"></p><h2 id="eureka-server集群" tabindex="-1"><a class="header-anchor" href="#eureka-server集群" aria-hidden="true">#</a> Eureka Server集群</h2><p>可以运行多个Eureka Server实例来组建Eureka Server集群。不像zk那样，实例间会有master/slave之分，存在leader的选举，eureka server实例之间是互相平等的。</p><p>对某个eureka server的所有操作都会复制到该实例已知的其他eureka server实例之中。如果某个eureka server实例不可用，eureka client则会自动切换到另外一台eureka server实例进行相关操作。当eureka server实例恢复后，则又会重新对eureka client提供服务。</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079372179.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>某个eureka server启动后，会首先尝试从已知的eureka server实例中获取注册表信息，完成初始化</p><p>eureka server和servcie provider直接会通过心跳机制定时更新注册表信息。如果一定时间内，eureka server没有收到service provider的心跳信息，则会将该service provider从注册表中移除。</p><p>如果某个eureka server实例在短时间内丢失了过多心跳信息，这个时候该实例将会进入**<code>自我保护模式</code>** ，在自我保护模式下，该eureka server实例不会再注销任何service provider节点。</p><h3 id="自我保护模式" tabindex="-1"><a class="header-anchor" href="#自我保护模式" aria-hidden="true">#</a> 自我保护模式</h3><p>默认情况下如果某个 eureka server 实例每分钟收到的心跳信息低于一个阈值，并且持续15分钟，该eureka server则会进入自我保护模式。</p><p>自我保护模式下，该eureka server实例不会再注销任何service provider节点。</p><p>当eureka server实例收到的心跳数量恢复到阈值之上，则会退出自我保护模式。</p><p>自我保护模式的设计思想就是：宁愿保留错误的service provider信息也不盲目注销任何可能健康的service provider.</p><p>这样的设计思想就会导致service consumer可能拿到不可用的服务节点信息，因此要求service consumer要有容错机制，不如重试、断路器等。</p><p>eureka server的自我保护模式是可关闭的，通过<code>eureka.server.enable-self-preservation = false</code>来禁用</p><h2 id="service-provider" tabindex="-1"><a class="header-anchor" href="#service-provider" aria-hidden="true">#</a> Service Provider</h2><p>service provider在启动的时候，会向eureka server提供自己的ip、端口和服务列表等信息。 eureka server会维护一个注册表来保存这些信息，该注册表结构为一个嵌套的map，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>private final ConcurrentHashMap&lt;String,Map&lt;String,Lease&lt;InstannceInfo&gt;&gt;&gt; registry = new ConcurrentHashMap&lt;String,Map&lt;String,Lease&lt;InstanceInfo&gt;&gt;&gt;&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当service provider实例的状态发生改变的时候，会向eureka server实例同步自己的服务信息，同时会执行replicateToPeers操作把信息同步给其他eureka server实例。</p><h3 id="续约与注销" tabindex="-1"><a class="header-anchor" href="#续约与注销" aria-hidden="true">#</a> 续约与注销</h3><p>servcie provider启动后会定期向eureka server发送心跳信息已达到续约的目的。</p><p>如果某个eureka server实例在一定时间内没有收到service provider的心跳信息，则会把改service provider从注册表中注销剔除。</p><h2 id="service-consumer" tabindex="-1"><a class="header-anchor" href="#service-consumer" aria-hidden="true">#</a> Service Consumer</h2><p>service consumer在启动后会从eureka server中获取所有实例的注册信息并缓存在本地。这些缓存信息每隔30s更新一次。因此即便所有eureka实例都不可用，service consumer还是可以利用本地的缓存信息和service provider进行通信</p><p>由于service consumer获取的服务实例信息可能是不可用的，所以service consumer需要有容错机制，比如请求重试、断路器 。spring cloud都提供了对应的工具：</p><ol><li>ribbon：实现客户端的负载均衡</li><li>hystrix：断路器</li><li>feign：restful web service客户端，整合了ribbon和hystrix。</li></ol><h3 id="ribbon" tabindex="-1"><a class="header-anchor" href="#ribbon" aria-hidden="true">#</a> Ribbon</h3><p>由以下几部分组成</p><ol><li><p>ServerList：服务器列表，有不同的实现类</p></li><li><p>ServerListFilter：服务器列表过滤器，也有不同的实现类</p></li><li><p>IPing：服务实例探测器，有不同的实现类</p></li><li><p>IRule：负载均衡策略，提供有 轮询、随机、响应时间加权等，类结构如下： <img src="https://cdn.justdopay.top/xiaoshujiang/1629079378559.png" alt="" loading="lazy"> 5.RestClient：rest web service 请求工具</p></li></ol><h3 id="hystrix" tabindex="-1"><a class="header-anchor" href="#hystrix" aria-hidden="true">#</a> Hystrix</h3><h4 id="雪崩效应" tabindex="-1"><a class="header-anchor" href="#雪崩效应" aria-hidden="true">#</a> 雪崩效应</h4><p>当某个基础服务不可用的时候，依赖于该服务的其他服务可能产生级联故障，进而导致整个服务故障的事件成为雪崩效应</p><p>在微服务中会有雪崩效应，在缓存集群中也可能发生雪崩效应</p><p>为了解决这个问题，则诞生了hystrix。</p><h4 id="hystrix的设计思想" tabindex="-1"><a class="header-anchor" href="#hystrix的设计思想" aria-hidden="true">#</a> hystrix的设计思想</h4><p>当连续调用某个服务N次都不响应的时候，hystrix则会启用，启用它会给服务器调用方返回一个符合预期的可处理的响应结果(fallback)，而不是让调用方长时间等待或则抛出一个调用方无法处理的异常，从而避免级联影响整体服务导致雪崩。</p><p>注意： 1. 在失败率较低的情况下，hystrix并不会启用，因此hystrix还是会把故障返回给客户端。 2. hystrix启用后返回的fallback是可有开发者定制的。</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079389736.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="hystrix调用监控" tabindex="-1"><a class="header-anchor" href="#hystrix调用监控" aria-hidden="true">#</a> hystrix调用监控</h4><p>hystrix会记录每分钟请求了多少次、多少失败、多少成功的等等信息，并且提供了可视化的工具hystrix dashboard对监控数据进行展示。图形化界面的含义如下：</p><figure><img src="https://cdn.justdopay.top/xiaoshujiang/1629079393753.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="feign" tabindex="-1"><a class="header-anchor" href="#feign" aria-hidden="true">#</a> Feign</h3><p>feign整合了ribbon和hystrix，因此我们不需要再显式的使用这两个组件。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>`,56),u={href:"https://windmt.com/2018/04/14/spring-cloud-1-services-governance/",target:"_blank",rel:"noopener noreferrer"},v=e("br",null,null,-1),E=e("h2",{id:"系统推荐",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#系统推荐","aria-hidden":"true"},"#"),r(" 系统推荐")],-1),f=e("p",null,[e("br"),e("br"),e("br"),e("br"),e("br"),e("br")],-1),g=e("hr",null,null,-1),k=e("hr",null,null,-1),x=e("ul",null,[e("li",null,[e("strong",null,"随机毒鸡汤"),r("：美貌会消逝，但蠢是永恒的。 "),e("br"),e("br"),e("img",{src:"https://images.pexels.com/photos/31986853/pexels-photo-31986853.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"African Angel",loading:"lazy"})])],-1);function _(m,b){const n=s("ExternalLinkIcon"),i=s("RouterLink");return o(),d("div",null,[p,e("blockquote",null,[e("p",null,[e("a",u,[r("Spring Cloud（一）：服务治理技术概览【Finchley 版】"),a(n)])])]),v,E,e("ul",null,[e("li",null,[a(i,{to:"/other/%E6%8F%90%E5%8F%96Docker%E9%95%9C%E5%83%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6.html"},{default:t(()=>[r("提取Docker镜像中的文件")]),_:1})]),e("li",null,[a(i,{to:"/other/Spring%20RetryTemplate.html"},{default:t(()=>[r("Spring RetryTemplate")]),_:1})]),e("li",null,[a(i,{to:"/software/middleware/mq/kafka.html"},{default:t(()=>[r("kafka")]),_:1})]),e("li",null,[a(i,{to:"/other/Paxos%E7%AE%97%E6%B3%95.html"},{default:t(()=>[r("Paxos算法")]),_:1})]),e("li",null,[a(i,{to:"/software/docker/Docker%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[r("Docker笔记")]),_:1})]),e("li",null,[a(i,{to:"/software/jvm/JVM%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"},{default:t(()=>[r("JVM异常处理")]),_:1})]),e("li",null,[a(i,{to:"/software/java-basic/%E4%B8%8D%E9%87%8D%E5%90%AF%20JVM%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E6%8E%89%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%EF%BC%9F.html"},{default:t(()=>[r("不重启 JVM，如何替换掉已经加载的类？")]),_:1})]),e("li",null,[a(i,{to:"/software/shodowsocks/ShadowsockServer%E9%85%8D%E7%BD%AE.html"},{default:t(()=>[r("ShadowsockServer配置")]),_:1})]),e("li",null,[a(i,{to:"/software/middleware/mysql/SQL%E4%BC%98%E5%8C%96.html"},{default:t(()=>[r("SQL优化")]),_:1})]),e("li",null,[a(i,{to:"/other/Git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:t(()=>[r("Git历史记录修改用户名和邮箱")]),_:1})]),e("li",null,[a(i,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{default:t(()=>[r("批量替换文件名中的指定字符串")]),_:1})]),e("li",null,[a(i,{to:"/other/https%E5%92%8Chttp%E6%B7%B7%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"},{default:t(()=>[r("https和http混用解决办法")]),_:1})])]),f,g,k,x])}const y=l(c,[["render",_],["__file","Spring Cloud（一）：服务治理技术概览【Finchley 版】.html.vue"]]);export{y as default};
