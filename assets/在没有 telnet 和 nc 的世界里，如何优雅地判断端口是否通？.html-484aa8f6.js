import{_ as o,$ as l,a0 as i,a1 as n,a3 as e,a4 as t,a5 as c,a2 as s,w as p}from"./framework-8c4427da.js";const r={},d=c(`<p>大家好！今天我们要聊一个运维界的经典问题：<strong>如何判断某个端口是否通？</strong> 但这次的背景有点特殊——我们身处一个“荒凉”的环境：既没有 <code>telnet</code>，也没有 <code>nc</code>，甚至连安装它们的权限都没有。这就好比你被困在一座孤岛上，手里只有一把生锈的小刀，却要修好一艘破船。别慌！今天我来教你几招“土法炼钢”，用现有的工具玩出花样！</p><h2 id="背景-一场-残酷-的限制" tabindex="-1"><a class="header-anchor" href="#背景-一场-残酷-的限制" aria-hidden="true">#</a> <strong>背景：一场“残酷”的限制</strong></h2><p>想象一下，你正在排查一个网络问题，突然发现目标服务器的某个端口似乎挂了。于是，你满怀希望地输入：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>telnet <span class="token number">192.168</span>.1.100 <span class="token number">3306</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果系统无情地回怼你：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: telnet: <span class="token builtin class-name">command</span> not found
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你心想：“没事，还有 <code>nc</code>！” 结果又是一记暴击：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: nc: <span class="token builtin class-name">command</span> not found
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更惨的是，你尝试安装这些工具时，系统直接甩给你一句：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Permission denied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时，你可能会怀疑人生：难道我要靠意念测试端口吗？当然不用！以下方法绝对能让你笑对困境。</p><h2 id="方法一-用-dev-tcp-偷偷摸摸搞事情" tabindex="-1"><a class="header-anchor" href="#方法一-用-dev-tcp-偷偷摸摸搞事情" aria-hidden="true">#</a> <strong>方法一：用 <code>/dev/tcp</code> 偷偷摸摸搞事情</strong></h2><p>Bash 这个老朋友其实藏了一手绝活——<code>/dev/tcp</code>。它虽然看起来像个文件，但实际上可以用来测试 TCP 端口。就像你在电影里看到特工用牙签撬锁一样，这个方法低调又高效。</p><h3 id="操作步骤" tabindex="-1"><a class="header-anchor" href="#操作步骤" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>输入以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token operator">&gt;</span> /dev/tcp/<span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果端口通了，系统会默不作声（因为它害羞）。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash: connect: Connection timed out
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果端口不通，系统会大声抗议：</li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token operator">&gt;</span> /dev/tcp/192.168.1.100/3306

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果返回 <code>Connection timed out</code>，说明端口要么太忙，要么根本不想理你。</p></li></ol><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li><code>/dev/tcp</code> 是 Bash 的隐藏技能，不是所有 Shell 都有。如果你用的是 <code>sh</code>，那不好意思，得先切换到 Bash（就像换上超级英雄的衣服）。</li><li>如果系统连 Bash 都没有，那你可能需要考虑跳槽到一个更有爱的环境。</li></ul><h2 id="方法二-用-curl-扮演-黑客" tabindex="-1"><a class="header-anchor" href="#方法二-用-curl-扮演-黑客" aria-hidden="true">#</a> <strong>方法二：用 <code>curl</code> 扮演“黑客”</strong></h2><p>如果系统中安装了 <code>curl</code>，你可以假装自己是个黑客，用它来测试端口。<code>curl</code> 虽然是 HTTP 工具，但它也支持其他协议，比如 <code>telnet</code>。这就像是用一把螺丝刀开红酒瓶塞——歪打正着，但效果杠杠的！</p><h3 id="操作步骤-1" tabindex="-1"><a class="header-anchor" href="#操作步骤-1" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>输入以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-v</span> telnet://<span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果端口通了，<code>curl</code> 会像导游一样带你参观连接详情。</p></li><li><p>如果端口不通，<code>curl</code> 会告诉你：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>curl: <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> Failed to connect to <span class="token operator">&lt;</span>目标地址<span class="token operator">&gt;</span> port <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>: Connection timed out
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-v</span> telnet://192.168.1.100:3306
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-1" tabindex="-1"><a class="header-anchor" href="#注意-1" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 <code>curl</code>，别担心，你可以装个假发假装自己是 <code>curl</code>（开玩笑啦，请看方法三）。</li><li>这种方法适合那些喜欢“黑科技”的人，毕竟谁不想偶尔扮演一下黑客呢？</li></ul><h2 id="方法三-用-python-写个-侦探-脚本" tabindex="-1"><a class="header-anchor" href="#方法三-用-python-写个-侦探-脚本" aria-hidden="true">#</a> <strong>方法三：用 Python 写个“侦探”脚本</strong></h2><p>如果你的系统中有 Python，恭喜你！你可以写一个简单的脚本来当“侦探”，专门负责侦察端口的状态。Python 是个万能小助手，就像瑞士军刀一样，走到哪都能派上用场。</p><h3 id="脚本示例" tabindex="-1"><a class="header-anchor" href="#脚本示例" aria-hidden="true">#</a> <strong>脚本示例</strong></h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> socket

<span class="token keyword">def</span> <span class="token function">test_port</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 创建一个套接字对象</span>
        sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
        sock<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 设置超时时间为 5 秒</span>
        result <span class="token operator">=</span> sock<span class="token punctuation">.</span>connect_ex<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Port </span><span class="token interpolation"><span class="token punctuation">{</span>port<span class="token punctuation">}</span></span><span class="token string"> is open on </span><span class="token interpolation"><span class="token punctuation">{</span>host<span class="token punctuation">}</span></span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Port </span><span class="token interpolation"><span class="token punctuation">{</span>port<span class="token punctuation">}</span></span><span class="token string"> is closed or unreachable on </span><span class="token interpolation"><span class="token punctuation">{</span>host<span class="token punctuation">}</span></span><span class="token string">.&quot;</span></span><span class="token punctuation">)</span>
        sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Error: </span><span class="token interpolation"><span class="token punctuation">{</span>e<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token comment"># 测试目标地址和端口</span>
test_port<span class="token punctuation">(</span><span class="token string">&quot;&lt;目标地址&gt;&quot;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="操作步骤-2" tabindex="-1"><a class="header-anchor" href="#操作步骤-2" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>将 <code>&lt;目标地址&gt;</code> 和 <code>&lt;目标端口&gt;</code> 替换为实际值。</p></li><li><p>运行脚本：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>python3 detective.py
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-2" tabindex="-1"><a class="header-anchor" href="#注意-2" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 Python，那说明你的环境真的太“原始”了，建议给它升级一下（或者送它去博物馆参展）。</li><li>这个脚本就像一个私人侦探，专治各种“端口失踪案”。</li></ul><h2 id="方法四-用-ss-或-netstat-查-本地情报" tabindex="-1"><a class="header-anchor" href="#方法四-用-ss-或-netstat-查-本地情报" aria-hidden="true">#</a> <strong>方法四：用 <code>ss</code> 或 <code>netstat</code> 查“本地情报”</strong></h2><p>如果问题出在本地服务本身，可以检查服务器是否正在监听指定端口。这就像是在家里翻箱倒柜找钥匙，虽然笨，但有效。</p><h3 id="操作步骤-3" tabindex="-1"><a class="header-anchor" href="#操作步骤-3" aria-hidden="true">#</a> <strong>操作步骤</strong></h3><ol><li><p>使用 <code>ss</code> 或 <code>netstat</code> 查看监听的端口：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ss <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">netstat</span> <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>目标端口<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如果没看到目标端口，说明服务可能睡着了，或者干脆罢工了。</li></ul></li><li><p>示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ss <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">3306</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h3 id="注意-3" tabindex="-1"><a class="header-anchor" href="#注意-3" aria-hidden="true">#</a> <strong>注意</strong></h3><ul><li>如果系统中没有 <code>ss</code> 或 <code>netstat</code>，那就只能靠耳朵听服务器有没有发出奇怪的声音了（开个玩笑，其实可以用方法五）。</li><li>这种方法适合那些喜欢“自检”的人，毕竟有时候问题就出在自己身上。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><p>在没有 <code>telnet</code> 和 <code>nc</code> 的世界里，我们依然可以用以下方法判断端口是否通：</p><ol><li>用 <code>/dev/tcp</code> 悄悄摸摸搞事情。</li><li>用 <code>curl</code> 扮演“黑客”。</li><li>用 Python 写个“侦探”脚本。</li><li>用 <code>ss</code> 或 <code>netstat</code> 查“本地情报”。</li></ol><p>每种方法都有它的乐趣和挑战，希望你能在这个受限环境中找到属于自己的快乐！<strong>记住，技术的世界没有绝境，只有创意不足的头脑！</strong> 😎</p><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,43),u=n("p",null,[n("br"),n("br"),n("br"),n("br"),n("br"),n("br")],-1),h=n("hr",null,null,-1),k=n("hr",null,null,-1),v=n("ul",null,[n("li",null,[n("strong",null,"随机毒鸡汤"),s("：不努力是会被合并同类项的，你要做那个，被提取出来的公因式。 "),n("br"),n("br"),n("img",{src:"https://images.pexels.com/photos/3178818/pexels-photo-3178818.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",alt:"A young woman works remotely at a café, using her laptop and external hard drive.",loading:"lazy"})])],-1);function m(b,g){const a=p("RouterLink");return l(),i("div",null,[d,n("ul",null,[n("li",null,[e(a,{to:"/software/unclassified/Git%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[s("Git笔记")]),_:1})]),n("li",null,[e(a,{to:"/software/middleware/redis/Redis%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[s("Redis笔记")]),_:1})]),n("li",null,[e(a,{to:"/software/java-basic/%E5%BC%B1%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B.html"},{default:t(()=>[s("弱引用示例")]),_:1})]),n("li",null,[e(a,{to:"/other/istio%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"},{default:t(()=>[s("istio基础知识")]),_:1})]),n("li",null,[e(a,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1.html"},{default:t(()=>[s("批量修改git历史记录中的用户名和邮箱")]),_:1})]),n("li",null,[e(a,{to:"/software/docker/Centos%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker.html"},{default:t(()=>[s("Centos离线安装Docker")]),_:1})]),n("li",null,[e(a,{to:"/software/shodowsocks/ShadowsockServer%E9%85%8D%E7%BD%AE.html"},{default:t(()=>[s("ShadowsockServer配置")]),_:1})]),n("li",null,[e(a,{to:"/other/MyBatis%20xml%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86.html"},{default:t(()=>[s("MyBatis xml特殊字符处理")]),_:1})]),n("li",null,[e(a,{to:"/software/middleware/mysql/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1Seata.html"},{default:t(()=>[s("分布式事务Seata")]),_:1})]),n("li",null,[e(a,{to:"/software/unclassified/%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{default:t(()=>[s("批量替换文件名中的指定字符串")]),_:1})]),n("li",null,[e(a,{to:"/software/spring/SpringCloud%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86.html"},{default:t(()=>[s("SpringCloud总体认识")]),_:1})]),n("li",null,[e(a,{to:"/intro.html"},{default:t(()=>[s("intro")]),_:1})])]),u,h,k,v])}const _=o(r,[["render",m],["__file","在没有 telnet 和 nc 的世界里，如何优雅地判断端口是否通？.html.vue"]]);export{_ as default};
