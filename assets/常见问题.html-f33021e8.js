import{_ as o,$ as l,a0 as r,a1 as e,a3 as t,a4 as n,a5 as s,a2 as a,w as p}from"./framework-b3a0f150.js";const d={},c=s(`<h2 id="如何解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#如何解决循环依赖的" aria-hidden="true">#</a> 如何解决循环依赖的</h2><p>先说网上流程很广的所谓的三级缓存吧 <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758835364709600.png" alt="" loading="lazy"> 总之就是三个map。</p><p>假设A依赖B，B依赖A（非构造器互相依赖，构造器互相依赖无法解决） spring先创建a，然后把自己放到三级缓存中，然后进行依赖注入，发现依赖b,然后分别去一级、二级、三级缓存中找，都没找到 于是spring接着创建b，spring把b先new出来，然后把自己放入三级缓存中，然后进行依赖注入，发现依赖a，于是分别去一级、二级 三级缓存中找，结果在三级缓存中找到a，于是把a从三级缓存中移除并把a放到二级缓存中。然后b的依赖注入顺利完成，b创建成功，于是把自己从三级缓存中移除，放到一级缓存中。 然后回过了头接着对a进行依赖注入，然后再次从三个缓存中找，结果在一级缓存中找到了b，完成依赖注入，a创建完成，并把二级缓存中 移除，然后把自己放入一级缓存。</p><p>上面是网上广为流传的说法，这个说法我不是很赞同哈。</p><p>不赞同的点不是这个流程，这个流程应该和代码的相差不大，我不赞同的是我觉得这个说法夸大了所谓的缓存的作用，给人的感觉是因为三级缓存解决了循环依赖</p><p>实际不用三级，就用一个map也能搞定。因为只要能new出来，那么就能先能先让其他bean先引用</p><h2 id="beanfactory与factorybean的区别" tabindex="-1"><a class="header-anchor" href="#beanfactory与factorybean的区别" aria-hidden="true">#</a> BeanFactory与FactoryBean的区别</h2><p>看名字知道，BeanFactory是个bean工厂，也就是来生产bean的，由他生产的bean会经过spring的生命周期， 比如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>populateBean
initilaizeBean
    invokeAwareMethods
    applyBeanPostProcessorsBeforeInitialization
    invokeInitMethods
        InitializingBean#afterPropertiesSet
        自定义的init方法
    applyBeanPostProcessorsAfterInitialization
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后FactoryBean是一个bean， 他既是一个普通的bean,也不是一个普通的bean.</p><p>说他是普通bean，是因为他和我们平常写的controller，service等一样，创建factorybean的时候也会经过上面的生命周期。</p><p>说他不是普通的bean，是因为这个bean又可以通过调用getObject方法来创建bean并交给spring管理。但是通过这个方法创建的bean就不会经过上面的生命周期。 可以通过这种方式来创建第三方jar包里的实例对象。 <s>有点像我们平时用得@Bean注解一样</s>（@Bean注解创建的bean也会经过spring的生命周期）</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758683689872700.png" alt="" loading="lazy"></h2><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758694081149000.png" alt="" loading="lazy"></h2><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/758714434336800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> spring事务</h2><p>按下面方式成对记忆</p><ol><li>REQUIRED， REQUIRED_NEW</li><li>SUPPORTS， NOT_SUPPORTED</li><li>MANDATORY， NEVER</li><li>NESTED</li></ol><h2 id="springbootapplication注解" tabindex="-1"><a class="header-anchor" href="#springbootapplication注解" aria-hidden="true">#</a> SpringBootApplication注解</h2><p>@SpringBootApplication可以看做下面三个注解的合集</p><ol><li><p>@Configuration</p><blockquote><p>允许在 Spring 上下文中注册额外的 bean 或导入其他配置类，用来标记当前类是一个配置类</p></blockquote></li><li><p>@ComponentScan</p><blockquote><p>扫描被@Component (@Repository,@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p></blockquote></li><li><p>@EnableAutoConfiguration</p><blockquote><p>启用 SpringBoot 的自动配置机制</p></blockquote></li></ol><p>重点说说 @EnableAutoConfiguration</p><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration</h3><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-09-16/771104096701700.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个注解上面有个import注解，import注解的使用看下文。 通过import注解导入了一个ImportSelector的实现类，类名想不起来了 我们知道如果导入的是一个ImportSelector的实现类，那么spring会执行里面的selectImports方法来得到需要创建 的bean的类全名。在这个实现类的这个方法里，会读取类路径下的spring.factories文件，这个文件就定义了各种普通类，配置类</p><p>总结：</p><ol><li><p>如果我们自己写了组件，想要给被人使用，就可以在jar包中添加spring.factories文件，并把相关的配置类写上去，这样其他人只需要吧 这个jar包放入类路径下即可</p></li><li><p>通过spring.factories文件的方式是不需要其他额外工作就可以激活相关功能的，我们还可以也写一个类似Enable的注解， 再这个注解上面加上Configuration注解，或者import注解，这样只要在启动类上加上这个注解就能激活相关功能</p></li></ol><h3 id="import注解" tabindex="-1"><a class="header-anchor" href="#import注解" aria-hidden="true">#</a> @Import注解</h3><p>可以导入几种类：</p><ol><li>普通类 <blockquote><p>这个情况会创建这个普通的实例</p></blockquote></li><li>ImportSelector实现类 <blockquote><p>如果导入的是这个类，就会执行这个类的importSelect方法，这个方法会返回需要创建的bean的类全名， 然后spring就会根据类全名创建bean</p></blockquote></li><li>ImportBeanDefinitionRegistrar实现类 <blockquote><p>导入这种类型的类，就会执行这个类的registerBeanDefinitions方法， 可以在这个方法里定义BeanDefinition并进行注册，这样spring就能根据 BeanDefinition来创建bean</p></blockquote></li></ol><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,32),u=e("p",null,[e("br"),e("br"),e("br"),e("br"),e("br"),e("br")],-1),h=e("hr",null,null,-1),b=e("hr",null,null,-1),g=e("ul",null,[e("li",null,[e("strong",null,"随机毒鸡汤"),a("：当我过得好了，我那些真心的朋友，都会来找我。 "),e("br"),e("br"),e("img",{src:"https://tuapi.eees.cc/api.php?category=fengjing&type=302&uuid=633ae9a2-dbac-4f86-b531-a5a944a566b2",alt:"",loading:"lazy"})])],-1);function m(E,B){const i=p("RouterLink");return l(),r("div",null,[c,e("ul",null,[e("li",null,[t(i,{to:"/software/middleware/mysql/MySQL%E6%9D%82%E9%A1%B9.html"},{default:n(()=>[a("MySQL杂项")]),_:1})]),e("li",null,[t(i,{to:"/other/Git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%B9%B6push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html"},{default:n(()=>[a("Git合并多个提交并push到远程仓库")]),_:1})]),e("li",null,[t(i,{to:"/other/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8.html"},{default:n(()=>[a("MySQL高可用")]),_:1})]),e("li",null,[t(i,{to:"/other/%E6%98%AF%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8MapStruct%E6%9B%BF%E4%BB%A3BeanUtils%E4%BA%86.html"},{default:n(()=>[a("是时候使用MapStruct替代BeanUtils了")]),_:1})]),e("li",null,[t(i,{to:"/other/Sublime%20Text%20%E6%A0%BC%E5%BC%8F%E5%8C%96JSON.html"},{default:n(()=>[a("Sublime Text 格式化JSON")]),_:1})]),e("li",null,[t(i,{to:"/software/docker/Centos%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker.html"},{default:n(()=>[a("Centos离线安装Docker")]),_:1})]),e("li",null,[t(i,{to:"/other/Arthas%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html"},{default:n(()=>[a("Arthas使用记录")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/Markdown%E8%BD%AF%E4%BB%B6%E6%AF%94%E5%AF%B9.html"},{default:n(()=>[a("Markdown软件比对")]),_:1})]),e("li",null,[t(i,{to:"/software/spring/SpringCloud%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86.html"},{default:n(()=>[a("SpringCloud总体认识")]),_:1})]),e("li",null,[t(i,{to:"/software/unclassified/%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"},{default:n(()=>[a("表单重复提交解决方案")]),_:1})]),e("li",null,[t(i,{to:"/other/Hbase%20%E6%80%BB%E8%A7%88.html"},{default:n(()=>[a("Hbase 总览")]),_:1})]),e("li",null,[t(i,{to:"/other/WebSocket%20SpringBoot%20Demo.html"},{default:n(()=>[a("WebSocket SpringBoot Demo")]),_:1})])]),u,h,b,g])}const A=o(d,[["render",m],["__file","常见问题.html.vue"]]);export{A as default};
