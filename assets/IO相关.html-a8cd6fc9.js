import{_ as o,$ as c,a0 as u,a1 as n,a2 as a,a3 as s,a4 as t,a5 as p,w as l}from"./framework-b3a0f150.js";const r={},d=p('<h2 id="_5中io模型-主要指网络io" tabindex="-1"><a class="header-anchor" href="#_5中io模型-主要指网络io" aria-hidden="true">#</a> 5中IO模型（主要指网络io）</h2><p>任何网络IO都会涉及到两个阶段： A.等待数据准备完成<br> B.将数据从内核态拷贝到进程中。</p><p>五中IO模型的区别就在这两个阶段有所不同。</p><h3 id="阻塞io" tabindex="-1"><a class="header-anchor" href="#阻塞io" aria-hidden="true">#</a> 阻塞IO</h3><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629078787440.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><h3 id="非阻塞io" tabindex="-1"><a class="header-anchor" href="#非阻塞io" aria-hidden="true">#</a> 非阻塞IO</h3><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629078780021.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><h3 id="io复用-也称-事件驱动io" tabindex="-1"><a class="header-anchor" href="#io复用-也称-事件驱动io" aria-hidden="true">#</a> IO复用（也称 事件驱动IO）</h3><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629078774679.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><h3 id="异步io" tabindex="-1"><a class="header-anchor" href="#异步io" aria-hidden="true">#</a> 异步IO</h3><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629078760729.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><p>jdk是支持异步io</p><h3 id="信号驱动io-java不支持" tabindex="-1"><a class="header-anchor" href="#信号驱动io-java不支持" aria-hidden="true">#</a> 信号驱动IO（JAVA不支持）</h3><h3 id="常见io" tabindex="-1"><a class="header-anchor" href="#常见io" aria-hidden="true">#</a> 常见io</h3><h2 id="java-nio" tabindex="-1"><a class="header-anchor" href="#java-nio" aria-hidden="true">#</a> Java NIO</h2>',15),k=n("li",null,[n("p",null,"传统io和nio的区别?"),n("ol",null,[n("li",null,[n("p",null,"前者是面向流的，inputstream和outputstream只能单向传输数据。而后者是面向块面向缓冲的，效率更高一些。主要涉及到三类对象：Channel,Buffer,Selector。所有对channel的读写都必须通过buffer来完成")]),n("li",null,[n("p",null,"在网络io方面，前者采用的io模型是 阻塞io，一个线程同时只能监听一个socket；而后者采用的io模型是 io复用，可以支持一个线程同时监听多个socket连接。")]),n("li",null,[n("p",null,"还提供了其他一些功能：比如零拷贝，直接缓冲，内存映射")])])],-1),h={href:"https://tech.meituan.com/2016/11/04/nio.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://juejin.cn/post/6844903949359644680#heading-15",target:"_blank",rel:"noopener noreferrer"},f=p(`<h3 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h3><p>Channel主要分了两类: SelectableChannel（网络相关的）; FileChannel（本地文件相关的）</p><ol><li><p>SelectableChannel</p><ol><li>ServerSocketChannel(TCP，监听套接字)</li><li>SocketChannel(TCP)</li><li>DatagramChannel(UDP)</li></ol></li><li><p>FileChannel</p><ol><li><p>transferTo</p></li><li><p>transferFrom</p></li></ol><p>这两个方法在操作系统的支持下可以实现<strong>零拷贝</strong>。一般情况下是将数据从内核态拷贝到用户态，然后再从用户态拷贝到目标通道的内核态中。这样就避免了内核空间拷贝到用户空间的内存拷贝操作，性能所以得到提升。</p><p>获取FileChannel对象的方式：</p><ol><li>通过FileInputStream的getChannel方法得到</li><li>通过FileOutputStream的getChannel方法得到</li><li>通过RandomAccessFile的getChannel方法得到</li></ol><p>三个方法的底层都是sendfile系统调用，通过man sendfile查看手册可知，sendfile的数据来源必须是一个文件（并不是很严格的说法，但肯定不能是套接字），数据的去向可以是任意的文件（普通的磁盘文件或者套接字等）</p><figure><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-08-31/427720748217300.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ol><h3 id="buffer" tabindex="-1"><a class="header-anchor" href="#buffer" aria-hidden="true">#</a> Buffer</h3><ol><li><p>读写Channel中的数据，都必须通过Buffer(缓冲区)进行操作</p></li><li><p>缓冲区本质上就是一个数组，常用的Buffer如下：</p><ol><li>CharBuffer</li><li>ByteBuffer 长度固定，不能动态扩展和收缩</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>MappedByteBuffer</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    limit <span class="token operator">=</span> position<span class="token punctuation">;</span>
    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    limit <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mark <span class="token operator">=</span> position<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> mark<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidMarkException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    position <span class="token operator">=</span> m<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">ByteBuffer</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hb<span class="token punctuation">,</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">position</span><span class="token punctuation">(</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">limit</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">discardMark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

mark和reset配合使用
clear：恢复buffer初始状态
rewind：position位置重置
compact：把position到limit间的数据拷贝到开始位置，然后postion位置放到后面一个位置


同步异步：关注事件发生时的行为
阻塞非阻塞：关注等待事件事的状态
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>MappedByteBuffer （<strong>零拷贝</strong>） 通过FileChannel的map方法来得到MappedByteBuffer对象，使用它可以避免内核态到用户态和用户态到内核态的数据拷贝。底层实现是调用操作系统的mmap来实现的</p><p>数据不会复制到用户空间，只在内核空间，但是应用程序可以直接操作该内存。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">MappedByteBuffer</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">MapMode</span> mode<span class="token punctuation">,</span> <span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>MapMode有三种：</p><ol><li><p>READ_ONLY : 只读</p></li><li><p>READ_WRITE : 读写</p><p>实验通过RandomAccessFile.getChannel().map方法，多次map同一个文件相同的为止，通过/proc/pid/maps可以看到多个多个映射的内存快，但通过gdb修改其中一个内存块， 然后dump memory另一个内存块，发现另一个内存块的内容也变了 <img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-08-31/428879815556400.png" alt="" loading="lazy"><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-08-31/429152281428700.png" alt="" loading="lazy"><img src="https://cdn.justdopay.com/pasteimageintomarkdown/2022-08-31/429184633770100.png" alt="" loading="lazy"> 文件内容也发生了变化</p></li><li><p>PRIVATE（专用） : 写的时候采用了copy-on-write(COW)策略，更改后的结果不会写入磁盘，所以只对自己可见</p></li></ol><p>新增的三个方法：</p><ol><li><p>force : 在READ_WRITE模式下，此方法对缓冲区所做的内容更改强制写入文件（注：只有在读写模式下才会有用）</p></li><li><p>load : 将缓冲区的内容载入物理内存，并返回该缓冲区的引用</p></li><li><p>isLoaded : 判断缓冲区的内容是否在物理内存，如果在则返回true，否则返回false</p></li></ol></li><li><p>缓冲分片 slice()方法完成分片，对postion到limit之间的数据建立一个缓冲，两者共享同一个数据结构。</p></li><li><p>只读缓冲 asReadOnlyBuffer()完成只读设置，返回的缓冲与之前的缓冲共享同样的数据。</p></li><li><p>直接缓冲 通过直接缓冲可以避免一些数据拷贝操作</p></li><li><p>分散读和聚集写 对实现私有协议很有帮助。每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中</p></li></ol><h3 id="reactor模式" tabindex="-1"><a class="header-anchor" href="#reactor模式" aria-hidden="true">#</a> Reactor模式</h3>`,6),v={href:"https://zhuanlan.zhihu.com/p/92193290",target:"_blank",rel:"noopener noreferrer"},b=p(`<h3 id="selectionkey" tabindex="-1"><a class="header-anchor" href="#selectionkey" aria-hidden="true">#</a> SelectionKey</h3><ol><li>四种事件 <ol><li>CONNECT</li><li>ACCEPT</li><li>READ</li><li>WRITE</li></ol></li></ol><h3 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe" aria-hidden="true">#</a> 管道（pipe）</h3><ol><li>用于两个线程直接的单向数据传输</li><li>包含两个channel：sink,source。将数据写入sink channel ,从source channel读取数据。</li><li>原理如下：</li></ol><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629083970857.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><ol start="4"><li>管道只存在于内存中，有点类似于生产者消费者问题。管道就是一个存储消息的地方，某些线程生产消息，某些线程消费消息。空间满的时候生产者等待，没有消息的时候消费者等待</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//创建管道</span>
<span class="token class-name">Pipe</span> pipe <span class="token operator">=</span> <span class="token class-name">Pipe</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//将数据写入sink channle</span>
<span class="token class-name">Pipe<span class="token punctuation">.</span>SinkChannel</span> sinkChannel <span class="token operator">=</span> pipe<span class="token punctuation">.</span><span class="token function">sink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> newData <span class="token operator">=</span> <span class="token string">&quot;New String to write to file...&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>newData<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sinkChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//从source channel读取数据</span>
<span class="token class-name">Pipe<span class="token punctuation">.</span>SourceChannel</span> sourceChannel <span class="token operator">=</span> pipe<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bytesRead <span class="token operator">=</span> sourceChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="select-poll-epoll的区别" tabindex="-1"><a class="header-anchor" href="#select-poll-epoll的区别" aria-hidden="true">#</a> Select Poll EPoll的区别</h3><p>这三个都是多路复用io的实现方式，都可以监听多个文件描述符。</p><ul><li>select : 当发生了io事件时，它不知道具体是哪个发生了io事件，也不知道有几个，仅仅是知道，所以它就要采取轮训的方式来检查，所以时间复杂度是n.</li><li>poll : poll和select其实没有太大区别，主要是poll采用了链表的数据结构，所以没有最大连接数的限制，而select则有这方面的限制，时间复杂度也是n</li><li>epoll : 而采用epoll，当发生了io事件时，它不用通过轮训，它是直接知道是哪个发生了什么样的io事件，所以时间复杂度是1</li></ul>`,10),g={href:"https://www.cnblogs.com/aspirant/p/9166944.html",target:"_blank",rel:"noopener noreferrer"},y=n("h3",{id:"mappedbytebuffer和pagecache的关系-是不是就是pagecache",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#mappedbytebuffer和pagecache的关系-是不是就是pagecache","aria-hidden":"true"},"#"),a(" MappedByteBuffer和PageCache的关系？是不是就是PageCache？")],-1),B=n("p",null,"pagecache是操作系统层面做的一个优化。mmap则是把pagecache中的数据映射到用户空间的内存中。 这种方式相对于传统的文件读写方式就少了一个cpu-copy，也就是实现了零拷贝",-1),E=n("figure",null,[n("img",{src:"https://cdn.justdopay.com/xiaoshujiang/1629342109625.png",alt:"enter description here",tabindex:"0",loading:"lazy"}),n("figcaption",null,"enter description here")],-1),_={href:"https://www.cnblogs.com/juniorMa/articles/14086247.html",target:"_blank",rel:"noopener noreferrer"},w=p(`<h3 id="零拷贝" tabindex="-1"><a class="header-anchor" href="#零拷贝" aria-hidden="true">#</a> 零拷贝</h3><p>在Linux中，从一块存储拷贝到另外一块存储过程中避免了cpu-copy，这样的技术被称作零拷贝。</p><ol><li>传统方式读取数据后并通过网络发送 所发生的数据拷贝（存在cpu-copy）：</li></ol><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629083979533.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><pre><code>1. 发起read系统调用，执行了一次数据拷贝，从磁盘到内核空间
2. 然后将数据从内核空间拷贝至用户空间，发生第二次数据拷贝，read结束
3. 发起send系统调用，发生第三次数据拷贝，将数据从用户空间拷贝至内核空间(socket缓冲区)
4. 然后将数据从内核拷贝至协议引擎，发送第四次数据拷贝，send系统调用结束

4次上下文切换：
    1. 发起read调用：从用户态切换到内核态
    2. read调用结束：从内核态切换到用户态
    3. 发起send调用：从用户态切换到内核态
    4. send调用结束：从内核态切换到用户态
</code></pre><ol start="2"><li>零拷贝方式（以FileChannel的transferTo方法为例，不存在cpu-copy）</li></ol><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629083989812.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><pre><code>上图中的2，3步骤中涉及到的数据拷贝就省略了

2次上下文切换

linux内核2.4以后，socket缓冲区做了调整，如下图：
</code></pre><figure><img src="https://cdn.justdopay.com/xiaoshujiang/1629083994543.png" alt="enter description here" tabindex="0" loading="lazy"><figcaption>enter description here</figcaption></figure><p>FileChannel的map方法底层是借助操作系统的mmap来实现的 FilaChannel的transferTo及transferFrom是借助操作系统的sendfile来实现的 mmap及sendfile都是操作系统实现零拷贝的方式</p><h3 id="内存映射" tabindex="-1"><a class="header-anchor" href="#内存映射" aria-hidden="true">#</a> 内存映射</h3><h3 id="直接缓冲" tabindex="-1"><a class="header-anchor" href="#直接缓冲" aria-hidden="true">#</a> 直接缓冲</h3><ol><li>DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收</li><li>默认情况下 MaxDirectMemorySize 的大小等于 Xmx的值</li><li>直接内存空间不足，会触发full gc.</li></ol><h2 id="java-aio" tabindex="-1"><a class="header-anchor" href="#java-aio" aria-hidden="true">#</a> Java AIO</h2><br><h2 id="系统推荐" tabindex="-1"><a class="header-anchor" href="#系统推荐" aria-hidden="true">#</a> 系统推荐</h2>`,16),x=n("p",null,[n("br"),n("br"),n("br"),n("br"),n("br"),n("br")],-1),j=n("hr",null,null,-1),A=n("hr",null,null,-1),C=n("ul",null,[n("li",null,[n("strong",null,"随机毒鸡汤"),a("：最痛苦的事，不是失败，是我本可以。 "),n("br"),n("br"),n("img",{src:"https://tuapi.eees.cc/api.php?category=fengjing&type=302&uuid=2325c697-8d16-4f36-98b2-c0ef10185f54",alt:"",loading:"lazy"})])],-1);function F(D,I){const i=l("ExternalLinkIcon"),e=l("RouterLink");return c(),u("div",null,[d,n("ol",null,[k,n("li",null,[n("p",null,[a("扩展阅读： "),n("a",h,[a("https://tech.meituan.com/2016/11/04/nio.html"),s(i)])])]),n("li",null,[n("p",null,[a("扩展阅读： "),n("a",m,[a("https://juejin.cn/post/6844903949359644680#heading-15"),s(i)])])])]),f,n("p",null,[n("a",v,[a("https://zhuanlan.zhihu.com/p/92193290"),s(i)])]),b,n("p",null,[a("扩展阅读："),n("a",g,[a("https://www.cnblogs.com/aspirant/p/9166944.html"),s(i)])]),y,B,E,n("ul",null,[n("li",null,[a("扩展阅读： "),n("a",_,[a("https://www.cnblogs.com/juniorMa/articles/14086247.html"),s(i)])])]),w,n("ul",null,[n("li",null,[s(e,{to:"/other/JetBrains%20IDE%20%E5%85%A8%E7%A0%B4%E8%A7%A3.html"},{default:t(()=>[a("JetBrains IDE 全破解")]),_:1})]),n("li",null,[s(e,{to:"/software/middleware/mq/kafka.html"},{default:t(()=>[a("kafka")]),_:1})]),n("li",null,[s(e,{to:"/other/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.html"},{default:t(()=>[a("数据同步方案")]),_:1})]),n("li",null,[s(e,{to:"/software/docker/Docker%E7%AC%94%E8%AE%B0.html"},{default:t(()=>[a("Docker笔记")]),_:1})]),n("li",null,[s(e,{to:"/software/middleware/mysql/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html"},{default:t(()=>[a("分库分表")]),_:1})]),n("li",null,[s(e,{to:"/other/Spring%20Boot%E5%8D%87%E7%BA%A7%E5%88%B02%206%20x%E8%B8%A9%E7%9A%84%E5%9D%91.html"},{default:t(()=>[a("Spring Boot升级到2 6 x踩的坑")]),_:1})]),n("li",null,[s(e,{to:"/software/unclassified/Flutter%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2.html"},{default:t(()=>[a("Flutter开发需要涉及的知识点大纲")]),_:1})]),n("li",null,[s(e,{to:"/software/unclassified/%E5%88%B6%E4%BD%9CKVM%20ES%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.html"},{default:t(()=>[a("制作KVM ES镜像文件")]),_:1})]),n("li",null,[s(e,{to:"/software/unclassified/Javassist%E6%95%B4%E7%90%86.html"},{default:t(()=>[a("Javassist整理")]),_:1})]),n("li",null,[s(e,{to:"/other/PGSQL%E7%9A%84json%E5%92%8C%20jsonb%20%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"},{default:t(()=>[a("PGSQL的json和 jsonb 读写性能测试")]),_:1})]),n("li",null,[s(e,{to:"/other/%E5%89%8D%E7%AB%AFaxios%E4%B8%8B%E8%BD%BDcsv%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81.html"},{default:t(()=>[a("前端axios下载csv文件乱码")]),_:1})]),n("li",null,[s(e,{to:"/other/vuepress/vuepress-theme-hope%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97.html"},{default:t(()=>[a("vuepress-theme-hope使用心得")]),_:1})])]),x,j,A,C])}const z=o(r,[["render",F],["__file","IO相关.html.vue"]]);export{z as default};
